	.PAGE 'CONTROLLER'
	.SKIP 6
;***************************************************
;*         -SINGLE DRV VERSION / 2 STEPS TRK-      *
;*          8250 CONTROLER FOR MPI DRIVE           *
;*               DOUBLE/SINGLE SIDED               *
;*                  77/35 TRACKS                   *
;*                 MARCH 28, 1981                  *
;*       /MODIFIED BY RAY HUGHES 6/17/83 CJL/      *
;***************************************************
; -MODIFIED 9/2/83 STEP RATE =3MSEC/SETTLING =24MSEC
;---------------------------------------------------
;I/O REGISTERS
	*=$40
;--------- 6522 ------------------------------------
VIAA
VB	*=*+1 ;PORT B
;BIT 7 SYNC DETECT 1-NO 0-YES
;BIT 6 PLL CONTROL BIT
;BIT 5 MOTOR 0 OFF
;BIT 4 MOTOR 1 OFF
;BITS 3-2 STEPPER MOTOR DRIVE #0
;BITS 1-0 STEPPER MOTOR DRIVE #1
DIN	*=*+1 ;PORT A
VDDRB	*=*+1 ;DATA DIRECTION REGISTER B
	*=*+1
T1LL	*=*+1 ;TIMER 1 LATCH & COUNTER LOW
TIMER	*=*+1 ;TIMER 1 COUNTER HIGH
T1L	=T1LL
T1H	=TIMER
	*=*+5
ACR	*=*+1 ;AUX CONTROL REG
PCR	*=*+1 ;PERIPH CONTROL REG
;BIT 0:   (SET TO 0)
;CA1:BYTE READY 1:YES 0:NO
;BITS 1-3:
;CA2: FILL/SYNC
; NORMAL: XC
; SYNC/FILL: XE
;BIT 4:  (SET TO 1)
;CB1: ERR DETECTED 1:YES 0:NO
;BITS 5-7:
;CB2: READ/WRITE
;  WRITE: DX
;  READ: FX
IFR	*=*+1 ;INT FLAG REGISTER
IER	*=*+1 ;INT ENABLE REGISTER
	.PAG
;-------- 6530 ------------------
	*=$80
MITA	;
DOUT	*=*+1 ;PORT A
EOUT	*=*+1 ;DIR A
PB	*=*+1 ;PORT B
;BIT 6 *** UNUSED ***
;BIT 4 ODD HEAD SELECT
;BIT 3 WRITE PROTECT 1:YES
;BITS 2-1 FREQUENCY (BIT DENSITY)
;BIT 0 SWITCH 0: DRIVE #0
;             1: DRIVE #1
DDRB	*=*+1 ;DATA DIRECT REG B
	*=*+11
MITAT	*=*+1 ;TIMER/1024
;------6530 RAM -----------------
;0000-003F  0100-013F
;
	*=$0000
CLOCK	*=*+1 ; CONTROLLER CLOCK
MTRCLK	*=*+1 ; MTR CLOCK CLOCK/16
MTRTM	*=*+2 ;MOTOR TIMER
;+ WHEN MOTOR FULLY ON
;0 WHEN SHOULD TURN MOTOR OFF
DRVST	*=*+2 ;DRIVE STATUS WORDS
;BIT 7 ACCELERATING 0:NO 1:YES
;BIT 6 STEPPING 0:NO 1:YES
;BITS 5-0 TRACK#
TDIST	*=*+2 ;#STEPS TO NEW TRACK
COW	*=*+1 ;USED WITH INTERRUPT
WORK	*=*+2
;+0 CLOSEST SEEK DISTANCE
;+1 CLOSEST SEEK DIRECTION
DTRCK	*=*+1 ;# SPACES FOR FORMAT
DSECT	*=*+1 ;# SECTORS UNTIL DESIRED SECTOR
CSECT	*=*+1 ;CLOSEST SEC FROM CURRENT POS
STAB	*=*+5 ;SECT HEADER TAB
;SAME FORMAT AS HDRS TABLE
DRIVE	*=*+1 ;CURRENT DRIVE#
TRACK	*=*+1 ;TRK# FOR CLOSEST SEEK
NEXTS	*=*+1 ;NEXT SECTOR ON DRIVE
SECTR	*=*+1 ;#SECT/TRK
BUFPT	*=*+2
;L POINTER INTO BUFS TABLE
;H POINTER INTO BUFS TABLE
HDRPT	*=*+2
;L POINTER INTO HDRS TABLE
;H POINTER INTO HDRS TABLE
;IF =FF THEN NO JOB
FTNUM	*=*+1 ;FORMAT TAG
IP	*=*+2
CNT	*=*+1
JOB	*=*+1 ;CURRENT JOB BEING DONE
JOBNUM	*=*+1 ;CURRENT JOB ID
DRVTRK	*=*+2 ;TRK DRV IS ON CURRENTLY
SETL	*=*+2 ; HEAD SETTLING TIME
CHKSUM	*=*+1
BI	*=*+1
FLG2	*=*+1
NXTJOB	*=*+1 ; OPT TRACK SEEK
NXTRK	*=*+1 ; OPT TRACK SEEK
;------------------------------
;4K OF COMMUNITY PROPERTY
;
	* =$400
TICK	*=*+1 ;INTERRUPT INTERVAL
DELAY	*=*+1 ;MOTOR ACCERATION DELAY
CUTMT	*=*+1 ;MOTOR CUTOFF TIME
JOBS	*=*+15
;BIT 7 0:IGNORE 1:JOB PRESENT
;BITS 6-4 MODE
;  000:READ     (8) (0)
;  001:WRITE    (9) (1)
;  010:VERIFY   (A) (2)
;  011:SEEK     (B) (3)
;  100:BUMP     (C) (4)
;  101:JUMP     (D) (5)
;  110:EXECUTE  (E) (6)
;  011:SECSEK   (B) (3) X011 100D
; -BIT 0:DRIVE 0:#B 1:#A
;
	*=$421 ;HEADERS ARE AT $421
HDRS	*=*+120 ;15*8
;HEADERS FOR CURRENT BLOCKS
;-3: SYNC
;-2: SYNC
;-1: "08"
; 0: ID1
; 1: ID2
; 2: TRK# (BITS 7,6 PART OF ID)
; 3: SECTOR#
; 4: CHECKSUM
; 5: OFF
; 6,7: SPARE
;
;#SECTORS/TRK INITILIZED BY DOS FOR THIS CONTROLLER
TAB1	*=*+4 ;
GAP1	*=*+1 ;GAP 1 SIZE SET BY DOS
;USED IN FORMAT FOR MIN NUMBER OF CHARS LEFT
GAP2	*=*+1 ;
VERNUM	*=*+1 ; USED BY DOS
ACTJOB	*=*+1 ;ACTIVE JOB #
PHASE	*=*+2 ; PHASE OF STEPPER
	*=*+1 ;
NZONES	*=*+1 ; NUMBER OF ZONES
;DELAY ON PLLSYN CONTROL AFTER SYNC DETECT
SYNDLY	*=*+1 ;
WPSW	*=*+2 ;WRITE PROTECT SWITCH
LWPT	*=*+2
PBI	*=*+1
CFLG2	*=*+1
NSIDES	*=*+1
SPDVAR	*=*+1 ; SPEED MEASURE
UNUSED	*=*+1 ; UNUSED
	*=$4B0
;TRACK BOUNDRY TABLE, UP TO 4 ZONES
TAB3	*=*+8 ;
;DATA ON DISK PRECEEDED BY
;SYNC,SYNC,"07"
;CHKSUM FOLLOWS 256 DATA BYTES
;THEN APPROXIMATELY 16 SPACING BYTES
	*=$04EA
DOS	*=*+1
STEPS	*=*+2
MAXTRK	*=*+1
HDSETL	*=*+1
SYNCS	*=*+1
;
;------EQUATES------------------------
HEAD0	= $10
HEAD1	= $EF
JUMP	= $D0 ;JUMP TO BUFFER CODE
EXEC	= $60 ;START MOTOR THEN JUMP
BUMPC	= $40 ; RESTORE
WRTSYN	= $DE ;WRITE SYNC MODE
WRTDAT	= $DC ;WRITE DATA MODE
;PLL CONTROL BIT, 1= READ MODE/ 0= SEARCH MODE
PLLBIT	= $40 ;
FLG	= $133B
SKIP2	=$2C ;SKIP TWO BYTES INST
INIT	= $500
	*=$500
BUFS	*=*+$F00 ;=15*256
;SET OF 15 1 BLOCK (256 WORD) BUFFERS
	.PAGE 'START'
	.OPT LIST
;---------------------------------------------
	*=$FC00 ; ROM START
STARTI	.WORD START ;INDIR TO START
DONEI	.WORD ERROR ;INDIRECT TO DONE
RESET	LDY #2 ;WAIT FOR 2 SIGNALS
RESET1	STY $0400 ;STORE NON-ZERO FLAG
RESET2	LDA $0400
	BNE RESET2 ; WAIT FOR DOS
	DEY
	BNE RESET1 ; ONE MORE TIME
	JMP INIT ; DIAGNOSTICS & INIT CODE
;---------------------------------------------
START5	DEY ;SCAN NEXT JOB
	BPL START0 ;NEXT, TO START OVER
START	LDY #15-1 ; # OF JOBS
START0	CLI
	LDA JOBS,Y ; VALID JOB?
	BPL START5 ; NO
	STY JOBNUM
	CMP #JUMP ; JUMP CODE?
	BNE START1 ; NO
	JMP EX ; GOTO EXECUTE
START1	SEI
;------SINGLE DRV CHANGES--------
;AND #1 ; MASK DRIVE NUMBER
;TAX ; TRANSFER FOR INDEX
;
	JSR SNGLE ;TEST FOR SINGLE DRIVE
;--------------------------------
	STA DRIVE ;/SET DRV #
	LDA VB ;TEST MOTOR STATUS
	AND ANDC,X ; LOOK AT MOTOR ON
	BEQ START3 ; MOTOR IS ON
	EOR VB
	STA VB ; TURN MOTOR ON
	LDA MTRCLK ; SET TIME FOR
	ADC DELAY ;  ACCELERATION DELAY
	STA MTRTM,X
	LDA DRVST,X
	ORA #$80
	STA DRVST,X ;SET ACCL BIT
START3	LDA DRVST,X ; FULL SPEED?
	BMI START5 ; NO, STILL SET
	LDA MTRCLK
	STA MTRTM,X ;KEEP MTR RUNING
	DEC MTRTM,X
	LDA DRVST,X
START4	ASL A ; HEAD MOVING?
	BMI START5 ;YES, DO JOB
;-------------------------------
QUE	CLI
	LDY #15-1 ; # OF JOBS
	STY JOBNUM
QUE1	JSR SETJOB
	BMI QUE4
QUE2	DEC JOBNUM
	BPL QUE1
	LDY NXTJOB
	JSR SETJB1
	LDA NXTRK ;GET NEXT TRK
	SEI
	STA STEPS,X ;SAVE STEPS TO GO
;-----9/2/83--------------------
	LDA #$8 ;SETTLE TIME =21 MSEC
	STA SETL,X ;
;--------------------------------
	LDA #$41
	ORA DRVST,X ;SET STEPPING BITS
	STA DRVST,X
	LDA (HDRPT),Y ; TRACK
	STA DRVTRK,X ; STORE HEAD POSITION
QUE3	JMP START ; BACK TO START
QUE4	AND #1
	CMP DRIVE ; TEST IF SAME DRIVE
	BNE QUE2 ; NOT SAME DRIVE
	LDA PB ;CORRECT TRK ?
	ORA #HEAD0
	STA PB ;SELECT BOTTOM SIDE
	LDA (HDRPT),Y ; GET TRACK
	CMP TAB3 ; MAX TRACK PER SIDE
	BCC QUE5 ; T < MAX TRACK
	LDA PB
	AND #HEAD1
	STA PB ; SELECT TOP SIDE OF DISK
	LDA DRVTRK,X ; CURRENT TRACK
	CMP TAB3
	BCS QUE7 ; CURRENT TRACK > MAX TRACK
	ADC MAXTRK ;ADJ FOR TOP OF DISK
	BNE QUE6 ; JUMP
QUE5	LDA DRVTRK,X ; CURRENT TRACK
	CMP TAB3
	BCC QUE7 ; CURRENT TRACK < MAX TRACK
	SBC MAXTRK ;ADJ FOR BOTTOM OF DISK
QUE6	STA DRVTRK,X
QUE7	LDA DRVTRK,X
	BEQ GOTU
	SEC
	SBC (HDRPT),Y
	BEQ GOTU ; ON RIGHT TRACK
QUE8	STA NXTRK ; SAVE FOR LATER USE
	LDA JOBNUM
	STA NXTJOB
	BPL QUE2
;----------------------------------
GOTU	LDX #4
	LDA (HDRPT),Y ; LOAD TRACK NUMBER
	STA TRACK
	CMP TAB3
	BCS GOTU2 ; TRACK > MAX TRACK
GOTU1	CMP TAB3-1,X
	DEX
	BCS GOTU1
	BCC GOTU3
GOTU2	CMP TAB3+3,X
	DEX
	BCS GOTU2
GOTU3	LDA TAB1,X ;GET NUMBER OF SECTORS
	STA SECTR ;  ON TRACK
	TXA
	ASL A
	STA WORK ; TEMP SPACE
	LDA PB
	AND #$F8
	ORA WORK
	ORA DRIVE ; ADD DRIVE
	STA PB ; STORE BIT DENSITY
	LDX DRIVE
	LDA DRVST,X
	BMI QUE3 ; MOTOR STILL ACCELERATING
	LDA JOB
	CMP #BUMPC
	BEQ BUMP ; RESTORE HEAD TO TRACK 1
;
; MODE 110 (E)
; EXECUTE
;----------------------------------
EXE	CMP #EXEC
	BEQ EX
	JMP SEEK
EX	LDA JOBNUM
EX2	CLC
	ADC #>BUFS
	STA BUFPT+1
EX3	JMP (BUFPT) ; GO EXECUTE
;
; MODE 100 (C)
; BUMP (RESTORE)
;--------------------------------
BUMP	SEI
	LDA #$41
	STA DRVST,X
	LDA #1
	STA DRVTRK,X ; SET TRACK TO 1
	LDA NOTOUT,X
	ORA VB
	STA VB ; SET TRACK 1 PHASE
	LDA #92
	STA STEPS,X ; DO 92 STEPS
;-----9/2/83----------------------
	JMP BSETL ;GO SET SETTLE TIME
;---------------------------------
SETJOB	LDY JOBNUM
SETJB1	LDA JOBS,Y
	PHA
	AND #$78
	STA JOB
	TYA
	ASL A
	ASL A
	ASL A
	ADC #<HDRS
	STA HDRPT
	LDY #2
	PLA
	RTS
;---------------------
FSNUM	LDY #3
	LDA (HDRPT),Y
	STA STAB+3
FSNUM1	LDA #$7F
	STA CSECT
	LDA STAB+3
	CLC
	ADC #2
	CMP SECTR
	BCC FSNUM2
	LDA #0
FSNUM2	STA NEXTS
	LDX #15-1
	STX JOBNUM
	LDX #$FF
FSNUM3	JSR SETJOB
	BPL FSNUM5 ; NO JOB
	STA WORK
	AND #1
	CMP DRIVE
	BNE FSNUM5 ; NOT THE RIGHT DRIVE
	LDA (HDRPT),Y
	CMP TRACK
	BNE FSNUM5
	LDA JOB
	CMP #EXEC
	BEQ FSNUM5
	INY
	SEC
	LDA (HDRPT),Y
	SBC NEXTS
	BPL FSNUM4
	CLC
	ADC SECTR
FSNUM4	CMP CSECT
	BCS FSNUM5
	STA CSECT
	LDA JOBNUM
	TAX
	ADC #>BUFS
	STA BUFPT+1
FSNUM5	DEC JOBNUM
	BPL FSNUM3
	TXA
	BPL FSNUM6
	JMP START
FSNUM6	STX ACTJOB
	STX JOBNUM
	JSR SETJOB
FSNUM7	LDA JOB ;NEXT,READ
;----------------------------
; READ MODE= 000 (8)
;
READ	CMP #0 ; SET STATUS
	BNE WRITE
	JSR DSTRT ; START READING DATA
RD2	BVC RD2 ; NO TIME FOR JSR
	CLV ; CLEAR BYTE READY (V)
	LDA DIN ; LOAD BYTE
	STA (BUFPT)Y ; STORE IN BUFFER
	INY
	BNE RD2 ;LOOP FOR 256 BYTES
RD4	BVC RD4 ; WAIT FOR CKSUM
	LDA DIN
	STA CHKSUM
	LDA #$10 ; TEST FOR DECODE ERROR
	BIT IFR
	BNE ERR ; DECODE FLAG IS SET
	JSR CHKBLK
	CMP CHKSUM ; CMP THE CHECK SUM
	BNE CSIDB
	JMP DONE
;---------------------------------
CSIDB	LDA #5 ;DATA BLK CS ERROR
	.BYT SKIP2 ;/
ERR4	LDA #04 ;/
ERR	JMP ERROR
;---------------------------------
;START READING DATA
DSTRT	JSR SRCH ;SEARCH CORRECT HEADER
	JSR SYNC ;WAIT FOR START OF DATA
	CMP #7 ; START OF DATA
	BNE ERR4 ;/NEXT IF OK
	RTS
;
;-----------------------------------
; WRITE MODE 001 (9)
;-----------------------------------
;
WRITE	CMP #$10
	BNE VRFY
	JSR CHKBLK
	STA CHKSUM
	LDA PB
	AND #08 ;ISOLATE WR PROTECT BIT
	BNE ERR ;/($E3) NEXT IF OK
WRT2	JSR SRCH ; GET CORRECT BLOCK
	LDX GAP1 ; LOAD WAIT GAP 1
WRT4	BVC WRT4 ;WAIT X CHARS
	CLV
	DEX
	BNE WRT4
	LDA #WRTSYN ; WRITE SYNC MODE
	STA PCR
	LDA #WRTDAT
	LDX #$FF ; LOAD FILL CODE
	JSR OUT2 ; WRITE 4 SYNC CHARS OUT
	JSR OUT2 ; 1 ST
WRT6	BVC WRT6 ; 4 TH
	CLV
	STA PCR ; STORE NORMAL CODE MODE
	LDA #7
	STA DOUT ; 2ND SYNC
	LDY #0
;-----------------------------------
; WRITE BLOCK
WRT8	BVC WRT8
	CLV
	LDA (BUFPT),Y
	STA DOUT
	INY
	BNE WRT8 ; LOOP FOR WHOLE BLOCK
	LDX CHKSUM ; WRITE OUT CKSUM
WRT10	BVC WRT10
	CLV
	STX DOUT
	JSR OUT ; SEND A BYTE
	LDX #00
	JSR OUT ; SEND A BYTE
	LDA #$FC ; NORMAL, READ MODE
WRT12	BVC WRT12 ; TEST IF BYTE PRESENT
	CLV
	STA PCR ; CHANGE TO SEND SYNC
	LDX #40
WRT14	JSR BYTE
	DEX
	BNE WRT14
	LDY JOBNUM
	LDA JOBS,Y ; LOAD OLD WRITE JOB
	EOR #$30 ; MAKE INTO VERIFY
	STA JOBS,Y
	JMP FSNUM ;FIX SCTR# FOR NEXT JOB
;--------------------------------
; VERIFY  MODE= 010 (A)
;--------------------------------
;
VRFY	CMP #$20
	BNE SECSEK ; SECTOR SEEK
	JSR DSTRT ; START READING DATA
VFRY2	BVC VFRY2 ;NO TIME FOR JSR
	CLV
	LDA DIN ; GET BYTE
	CMP (BUFPT),Y ;COMPARE BUFFER
	BNE ERR7 ; VERIFY ERROR
	INY
	BNE VFRY2 ; 256 BYTES
	JMP RD4 ; COMPARE CKSUM BYTES
;
;-------------------------------------
; END READING DATA
;-------------------------------------
; MODE= 011 (B) X011 100D
; SECTOR SEEK
;-------------------------------------
SECSEK	JSR SRCH ;GET CORRECT BLOCK
	BEQ DONE ; JUMP TO DONE
;
SEEK	LDX #180 ; READ HEADER
	JSR HD4 ; GET BLOCK HEAD
	LDY #5-1
SEEK2	BVC SEEK2
	CLV
	LDA DIN ; GET BYTE
	STA STAB,Y ; STORE IN TABLE
	DEY
	BPL SEEK2 ; LOOP
	LDY #4 ; CREATE CKSUM
	LDA #0
SEEK4	EOR STAB,Y
	DEY
	BPL SEEK4
	CMP #0
	BNE CSERR ; BRANCH IF ERROR
	LDX DRIVE ;INDEX BY DRIVE#
	LDA STAB+2
	STA DRVTRK,X ;UPDATE CORRECT TRK#
	LDA JOB ; LOAD JOB TYPE
	CMP #$30 ; TEST IF SEEK
	BEQ ESEEK ; BRANCH IF YES
	LDY #1
SEEK6	LDA (HDRPT),Y ; LOAD ID
	CMP STAB,Y ;CHECK IF SAME AS HEADER
	BNE ERR11 ; BRANCH IF MISMATCH
	DEY
	BPL SEEK6 ; LOOP
	JMP FSNUM1 ;SCTRS TO SERVICE
;-----------------------------
; SEEK  MODE= 011 (B)
;-----------------------------
;
ESEEK	LDY #4
ESK2	LDA STAB,Y ; LOAD HEADER
	STA (HDRPT),Y ; STORE HEADER
	DEY
	BPL ESK2 ; LOOP FOR WHOLE HEADER
DONE	LDA #1 ;ERR CODE FOR NO ERROR
	.BYTE SKIP2
CSERR	LDA #9
	.BYTE SKIP2
ERR7	LDA #7
	.BYTE SKIP2
ERR11	LDA #11
ERJMP	JMP ERROR ; JUMP TO ERROR
;----------------------------------
; SEARCH FOR SPECIFIC BLOCK
;---------------------------------
SRCH	LDY #4-1
	LDA #0
SRCH2	EOR (HDRPT),Y ; COMPUTE CHECKSUM
	DEY
	BPL SRCH2
	LDY #4 ; OFFSET FOR CHECKSUM
	STA (HDRPT),Y ; STORE CHECKSUM
	LDY JOBNUM
	LDX #180 ; SEARCH FOR A SECTOR
SRCH4	JSR HD4 ;EVERY BYT IN THE HEADER
	LDY #5-1 ; MUST BE IDENTICAL
SRCH6	BVC SRCH6
	CLV
	LDA DIN
	CMP (HDRPT),Y ; COMPARE TO HEADER
	BNE SRCH4 ; LOOP IF NOT RIGHT BLOCK
	DEY
	BPL SRCH6 ; LOOP FOR WHOLE HEADER
	INY ; SET Y TO 0
SRCH8	RTS
;---------------------------------
; SEARCH FOR BLOCK HEAD
;---------------------------------
HEAD	JSR SYNC ;/
HD2	CMP #08 ;/
	BEQ SRCH8 ;/  ($F8)
HD4	CLI
	DEX ; X HAS MAX # OF TRIALS
	BNE HEAD ;NEXT IF ERROR !
;---------------------------------
; SEND ERROR CODE
;---------------------------------
ERR2	LDA #2 ; ERROR CODE
ERROR	LDY JOBNUM ; LOAD JOB#
	STA JOBS,Y ; SEND JOB STATUS
	PHA
	LDA MTRCLK
	LDX DRIVE
	ADC CUTMT
	STA MTRTM,X ;MOTOR ON LONGER
	PLA ; LOAD ERROR TYPE
	LSR A ; TEST IF OK EXIT
	BNE ERDONE ; BRANCH IF NOT
	JMP FSNUM ; LOOP FOR ALL SECTORS
ERDONE	LDX #$3F
	TXS ; PURGE STACK
	JMP START ; GO TO NEXT JOB
;
;----------------------------------------
; ERRORS:
; #1: NO ERROR
; #2: CAN'T FIND BLOCK HEAD
; #3: NO SYNC CHARACTER
; #4: DATA BLOCK NOT PRESENT
; #5: CHECKSUM ERROR
; #7: VERIFY ERROR
; #8: WRITE WITH WRITE PROTECT ON
; #9: CHECKSUM ERROR IN SEEKED HEADER
; #10: DATA RAN INTO NEXT HEADER
; #11: DISK ID MISMATCH
; #16: DECODING ERROR
;
;--------------------------------
; HUNT FOR SYNC CHARACTER
;--------------------------------
SYNC	LDA #30
	STA $1E ;/
SYNC2	LDA VB ;/
	AND #$BF ;/
	STA VB ;/
SYNC4	SEI
	LDA #$80+80
	STA TIMER ; 20 MS LIMIT
	LDA #3 ; ERROR CODE
	DEC $1E ;/
	BMI ERROR ; > 30 FALSE SYNCS
SYNC6	BIT TIMER ;TEST TIME LIMIT
	BPL ERROR ; BRANCH IF OVER
	BIT VB ; TEST IF SYNC PRESENT
	BMI SYNC6 ; LOOP UNTIL SYNC
	LDY SYNDLY ; LOAD SYNCDLY
WSYNC	BIT VB ; TEST SYNC PRESENT
	BMI SYNC2 ; GONE, FIND AGAIN
	DEY
	BNE WSYNC ; 10 US PER LOOP DELAY
	LDA VB ; GOTO READ MODE
	ORA #PLLBIT
	STA VB
	BIT DIN ; RESET VIA LATCHING DATA
	CLV
BYTE	BVC BYTE ;TEST IF BYTE PRESENT
	CLV
	LDA DIN ; LOAD BYTE
	RTS
;-----------------------------------
; BYTE TO BE SENT IS IN X
OUT2	JSR OUT ; DO 2 OUTS
OUT	BVC OUT ;DATA IN 6530 WAS LATCHED
	CLV
	STX DOUT ;WRITE NEW BYTE INTO PA
	RTS
;------------------------------------
CHKBLK	LDA #0 ; CREATE BLOCK CHKSUM
	TAY
CHKB10	EOR (BUFPT),Y
	INY
	BNE CHKB10
	RTS
;
;------------IRQS=---------------------
IRQ	PHA ;SAVE REGS
	TXA
	PHA
;------9/2/83-----------------------
	LDA #03 ; (3 MSEC STEP RATE)
;-----------------------------------
	STA MITAT ;SAVE IRQ INTERVAL RATE
	STA MITAT ;DO IT TWICE !!
	INC CLOCK
	LDA CLOCK
	AND #$0F
	BNE IRQ1
	INC MTRCLK
IRQ1	LDX #2-1
	LDA PB
	PHA ; SAVE PB
	ORA #1
IRQ2	STA PB ; SELECT DRIVE
	LDA PB
	AND #8 ; MASK WRITE PROTECT
	CMP LWPT,X ; CHECK LAST WRITE PROTECT
	STA LWPT,X
	BEQ IRQ3 ; NO CHANGE
	LDA #1
	STA WPSW,X ; SET SWITCH
IRQ3	LDA MTRCLK ;SERVICE MTR
	CMP MTRTM,X
	BNE IRQ5
	ASL DRVST,X
	BCS IRQ4
	LDA ANDC,X
	ORA VB
	STA VB ; TURN MOTOR OFF
IRQ4	LDA MTRCLK ;/KEEP MTR RUNING
	STA MTRTM,X
	DEC MTRTM,X
	CLC
	ROR DRVST,X
IRQ5	LDA STEPS,X ;SERVICE STEPPER
	BNE IRQ8
IRQ6	LDA SETL,X ; GET SETTLING TIME
	BEQ IRQ7 ; DONE SETTLING
	DEC SETL,X
	BPL IRQ14 ; JUMP, SERVICE OTHER DRIVE
IRQ7	STA PHASE,X ; .A = 0, FOR OLD DOS
	LDA DRVST,X ; ON TRACK
	AND #$BF
	STA DRVST,X ; CLEAR STEPPING FLAG
	JMP IRQ14 ; SERVICE OTHER DRIVE
IRQ8	ASL A ;0=OUT,1=IN/CY
IRQ9	LDA VB ;/$40
	AND PHASES,X ;/
	STA COW ;/
	LDA VB ;/
	AND NOTOUT,X ;/
	BCS IRQ10 ;/
	DEC STEPS,X ;/
	EOR NOTOUT,X ;/
	JMP IRQ11 ;/
IRQ10	INC STEPS,X ;/
IRQ11	EOR NOTIN,X ;/
	BEQ IRQ12 ;/
	CMP NOTOUT,X ;/
	BEQ IRQ12 ;/
	EOR NOTOUT,X ;/
IRQ12	ORA COW ;/ADD OLD STATE
IRQ13	STA VB ;/WRITE NEW STEPPER STATE
IRQ14	LDA PB
	AND #$FE ; DRIVE 0
	DEX ;/MORE DRV'S ?
	BPL IRQ2 ;/NO, THEN NEXT
IRQ15	LSR CFLG2
	PLA
	STA PB ; RESTORE DRIVE
	PLA
	TAX
	PLA
	RTI
;
;----------------------
PHASES	.BYTE $F3,$FC
NOTIN	.BYTE $08,$02
NOTOUT	.BYTE $0C,$03
ANDC	.BYTE $20,$10
;----------------------
BSETL	STA SETL,X ;SET BUMP SETTLE TIME
	JMP DONE
;------------------------------------------
SNGLE	AND #01 ;MASK DRIVE BIT
	TAX ;SAVE A COPY OF IT
	BNE SNG2 ;NEXT IF DRV #0
	RTS
SNG2	LDA #03 ;/SET ERROR CODE
	JMP ERROR ;DRV #1 SELECTED
;------------------------------------------
;
	*=$FFFB
CKBYT	.BYTE $00
	.WORD RESET
	.WORD IRQ
;CHECK GENERATOR
;----------------------------
; LOAD @ 2800 - PGM @ 2400-27FF
; .G 4000 TO RUN CHECK SUM PGM
;----------------------------
;
	*=$1800
GENCK	LDA #>$2400
	STA $1 ;MSB
	LDA #0
	STA CKBYT-$D800 ;START WITH A ZERO
	STA $0 ;LSB
	LDX #4 ;PAGE COUNT
	TAY ;CLR POINTER
	CLC
GENCK1	ADC ($0),Y ;NEXT BYTE
	INY ;
	BNE GENCK1 ;NEXT IF THIS PG DONE
	INC $1
	DEX ;ALL PG'S DONE ?
	BNE GENCK1 ;YES, THEN NEXT
	ADC #00 ;LAST CARRY
	STA $1
	LDA #>STARTI ;MEM ADDR
	SEC
	SBC $1 ;LESS CKSUM
	SBC #00
	STA CKBYT-$D800
	BRK ;FINISHED
	.END
