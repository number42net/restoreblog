.PAGE    'BASIC UTILITY ROUTINES'
STXTPT	LDA #TXTBNK
	STA TXTPTR+2
	CLC
	LDA TXTTAB
	ADC #255
	STA TXTPTR
	LDA TXTTAB+1
	ADC #255
	STA TXTPTR+1
	RTS
.SKIP 4
GETNUM	JSR     GETPIN  ;GET POSITIVE INTEGER
COMBYT	JSR     CHKCOM
	JMP     GETBYT
;
GTBYTC	JSR     CHRGET
GETBYT	JSR     FRMNUM
CONINT	JSR     POSINT
	LDX     FACMO
	BNE     FCER1
	LDX     FACLO
	JMP     CHRGOT
.SKIP 4
GETPIN	JSR     FRMNUM  ;EVALUATE THE FORMULA
GETADR	LDA     FACSGN
	BMI     FCER1
	LDA     FACEXP
	CMP     #145
	BCS     FCER1
	JSR     QINT
	LDA     FACMO
	LDY     FACMO+1
	STY     POKER
	STA     POKER+1
	RTS
;
BJMPS	;REFERENCED IN INITIALIZATION ROUTINE
FCER1	JMP     FCERR
.SKIP 4
;       THESE ROUTINES CHECK FOR CERTAIN 'VALTYP'
;       (C) IS NOT PRESERVED.
FRMNUM	JSR     FRMEVL
CHKNUM	CLC
	.BYTE      $24
CHKSTR	SEC
CHKVAL	BIT     VALTYP
	BMI     DOCSTR
	BCS     CHKERR
CHKOK	RTS
;
DOCSTR	BCS     CHKOK
CHKERR	LDX     #ERRTM
	JMP     ERROR
.SKIP 4
;
;       PRINT THE STR WHOSE DESCRIPTOR IS -> BY FACMO
STRPRT
	JSR     FREFAC  ;RETURN TEMP ->
	TAX             ;PUT COUNT INTO COUNTER
	LDY     #0
	INX
	JSR     MAPINX
;
;       OUTPUT X CHARACTERS TO DEVICE
STRP2	DEX
	BEQ     STRP3
	LDA (INDEX)Y
	JSR     OCHR    ;OUTPUT ONE CHAR
	INY
	JMP     STRP2   ;NEXT
STRP3	JMP     MAPTXT
;
;       OUTPUT SPACE
OSPC
	LDA     CHANNL
	BEQ     CRTSKP
	LDA     #' '
	.BYTE $2C       ;EAT NEXT TWO BYTES
CRTSKP	LDA     #29
	.BYTE $2C       ;EAT NEXT TWO BYTES
OUTQST	LDA     #'?'
;
;       OUTPUT ONE CHARACTER TO DEVICE
OCHR	JSR     BSOUT   ;OUTPUT CHARACTER
	AND     #$FF
	RTS
.PAGE   'DOS UTILITY ROUTINES.'
;              -MGM 7/23/79-
;
;       THIS IS THE DOS PARSER ROUTINE WHICH LOOKS AT LINES
;       PASSED TO IT AND VARIFIES THAT THE SYNTAX IS PROPER.
;
;       ENTRY   (DOSPRS)
;               A = PARSTS BIT WHICH MUST BE ZERO.
;
;       EXIT    A = PARSTS AS FOLLOWS
;
;       I-I-I-I-I-I-I-I-I
;       I7+6+5+4+3+2+1+0I
;       I-I-I-I-I-I-I-I-I
;        ^ ^ ^ ^ ^ ^ ^ ^ ====>  FN1 THIS BIT IS SET WHEN THE
;        | | | | | | | |             FIRST FILENAME IS PARSED
;        | | | | | | | ======>  FN2 SET FOR SECOND FILENAME
;        | | | | | |=========>  LA SET WHEN #LFN PARSED
;        | | | | |===========>  FA SET FOR DEVICE NUMBER
;        | | | | ============>  D1 SET FOR FIRST DISK UNIT
;        | | | ==============>  D2 SET FOR SECOND DISK UNIT
;        | | ================>  DOSRCL SET FOR RECORD SIZE
;        | ==================>  @ SET WHEN @ ENCOUNTERED.
;
;       THE FOLLOWING ARE THE VAILD BIT PATTERNS FOR PARSTS
;       AFTER PARSING FOR THE VARIOUS KEYWORDS
;
;                 7 6 5 4   3 2 1 0
;       (FORMAT)
;        HEADER   0 0 0 1   * 0 0 1
;        COLECT   0 0 0 *   * 0 0 0
;        BACKUP   0 0 1 1   * 0 0 0
;        COPY     0 0 1 1   * 0 0 0
;          OR..   0 0 * *   * 0 1 1
;        CONCAT   0 0 * *   * 0 1 1
;        BSAVE    * 0 0 *   * 0 0 1
;        DSAVE    * 0 0 *   * 0 0 1
;        BLOAD    0 0 0 *   * 0 0 1
;        DLOAD    0 0 0 *   * 0 0 1
;        CATLOG   0 0 0 *   * 0 0 *
;        RENAME   0 0 0 *   * 0 1 1
;        APPEND   0 0 0 *   * 1 0 1
;        SCRTCH   0 0 0 *   * 0 0 1
;        DOPEN    * * 0 *   * 1 0 1
;        DCLOSE   0 0 0 0   * * 0 0
;                 ^ ^ ^ ^   ^ ^ ^ ^
;                 @ L D D   F L F F
;                 R R 2 1   A A N N
;                 P E           2 1
;                 L L
;
;          "0" BITS ARE REQUIRED TO BE CLEAR.
;          "1" BITS ARE REQUIRED TO BE SET.
;          "*" BITS ARE OPTIONAL PARAMETERS.
.PAGE
;       ENTRY (DOSPRS)
;               PARSTX SHALL BE SET TO PREVENT ANY
;               AUXILIARY OPTIONS TO BE SPECIFIED.
;
;       ENTRY (DOSPRX)
;               X = PARSTX BITS WHIC MUST BE ZERO.
;       EXIT    X = PARSTX AS FOLLOWS
;
;       I-I-I-I-I-I-I-I-I
;       I7+6+5+4+3+2+1+0I
;       I-I-I-I-I-I-I-I-I
;        ^ ^ ^ ^ ^ ^ ^ ^ ====>  BNK IS SET FOR BANK OPTION
;        < < < < < < < ======>  OFFL SET FOR 1ST ADDRESS
;        < < < < < <=========>  OFFH SET FOR 2ND ADDRESS
;        < < < < <===========>  UNUSED
;        < < < < ============>  UNUSED
;        < < < = ============>  UNUSED
;        < < = = ============>  UNUSED
;        < = = = ============>  UNUSED
;
;       THE FOLLOWING ARE THE VAILD BIT PATTERNS FOR PARSTX
;       AFTER PARSING FOR THE VARIOUS KEYWORDS
;       ONLY TWO STMTS ARE ALLOWED BITS SET IN PARSTX.
;
;                 7 6 5 4   3 2 1 0
;       (FORMAT)
;        BSAVE    0 0 0 0   0 * * *
;        BLOAD    0 0 0 0   0 0 * *
;                 ^ ^ ^ ^   ^ ^ ^ ^
;                 ? ? ? ?   ? O O B
;                             F F N
;                             H L K
;          "0" BITS ARE REQUIRED TO BE CLEAR.
;          "1" BITS ARE REQUIRED TO BE SET.
;          "*" BITS ARE OPTIONAL PARAMETERS.
.SKIP 2
DOSTBL	.BYTE $FF,$FF,$FF,$FF,DOSLFN,DOSDSK,$6F
.SKIP 2
DOSPAR
	LDA     #0
;
DOSPRS	;SPECIAL ERROR FLAG ENTRY
	LDX    #$FF     ;NO AUX OPTIONS!
DOSPRX	;SPEC AUX ERROR FLAG ENTRY
	PHA             ;SAVE ERROR FLAGS
	TXA
	PHA
	LDA     #0
	STA     PARSTS
	STA     PARSTX
.SKI 1
	LDX     #DOSSPC-1 ;CLEAR DOS SCRATCH AREA
DOS01	STA     FBUFFR,X
	DEX
	BNE     DOS01
	LDX     #DOSSA-DOSOFL ;SET SOME DEFAULTS FROM TABLE
DOS02	LDA     DOSTBL,X
	STA     DOSOFL,X
	DEX
	BPL     DOS02
	LDX     DFBANK
	STX     DOSBNK
;
	JSR     CHRGOT  ;GET CURRENT CHR
	BNE     PARSE1  ;IF NOT END OF STATEMENT
;
DONE
	PLA             ;GET AUX ERROR FLAG
	AND     PARSTX  ; REPEATED,ILLEGAL PARAMS?
	BNE     DN20
	PLA             ;GET ERROR FLAGS
	JSR     PRMRPT
	LDA     PARSTS
	LDX    PARSTX
	RTS
;
PARSE1	CMP     #'#'
	BEQ     LOGADR  ;IF LOGICAL FILE NUMBER
	CMP     #'W'
	BEQ     RECLEN  ;IF RECORD LENGTH
	CMP     #'L'
	BEQ     RECLEN  ;IF RECORD LENGTH
	CMP     #'R'
	BNE     DOS5    ;IF NOT ????
	JSR     CHRGET  ;MOVE ON
	JMP     DELIM1
;
ON1	JSR     ON
SAV60	JMP     DEL1
;
UNIT1	JSR     UNIT    ;DO UNIT# PARSING
	BNE     SAV60     ;ALWAYS
;
BANK1	JSR     BANK
	BEQ     SAV60     ;ALWAYS
.SKIP 4
DOS5	CMP     #'D'
	BEQ     DRV1
	CMP     #TKON   ;"ON" TOKEN
	BEQ     ON1
	CMP     #'B'
	BEQ     BANK1
	CMP     #'U'
	BEQ     UNIT1
	CMP     #'P'
	BEQ     DOFFL
	CMP     #'I'
	BNE     DOS10   ;IF NOT IDENTIFIER
	BEQ     IDENT
;
.SKIP 4
LOGADR
	LDA     #4
	JSR     PRMRPT  ;CHECK FOR REPEATED PARAMETER
	JSR     GETVAL
	CPX     #0
	BEQ     QTYER2  ;IF ILLEGAL VALUE
	STX     DOSLA
	LDA     #4      ;SET LOGICAL ADDRESS FLAG
	BNE     SAV60   ;GET NEXT PARAMETER
DN20	JMP     SNERR
.SKIP 4
RECLEN
	TAX             ;SAVE CHAR
	LDA     #$40
	JSR     PRMRPT  ;CHECK FOR REPEATED PARAMETER
	CPX     #'W'
	BNE     RECOO
	JSR     CHRGET
	JMP     RECON   ;SET PARSTS
RECOO	JSR     GETVAL
	CPX     #0
	BEQ     QTYER2  ;ZERO ILLEGAL DOSRCL
	CPX     #255
	BEQ     QTYER2  ;ILLEGAL DOSRCL
	STX     DOSRCL  ;STORE PARCEL
;
RECON
	LDA     #$40    ;SET DOSRCL FLAG &
	BNE     TACKY1
;
DOS10	CMP     #'"'
	BEQ     NAME1
	CMP     #'('
	BEQ     NAME1
	BNE     DN20
;
.SKIP 4
DRV1
	LDA     #$10
	JSR     PRMRPT  ;CHECK FOR REPEATED PARAMETER
	JSR     GETVAL
	CPX     #2
	BCS     QTYER2  ;ILLEGAL DRV# IF >1
	STX     DOSDS1
	STX     DOSDS2
	LDA     #$10
TACKY1	BNE     DEL1
;
QTYER2	JMP     QTYERR
.SKIP 4
IDENT	LDA     DIDCHK
	BEQ     IDCON   ;ONLY 1 DOSDID ALLOWED
	BNE     DN20
;
DOFFL	LDA     #$02    ;CHK AUX STATUS
	JSR     PRXRPT
	JSR     GETOFF  ;GET OFFSET VALUE
	STY     DOSOFL
	STA     DOSOFL+1
	LDA     #$02
DLIMX1	ORA PARSTX      ;SET AUX STATUS BITS
	STA     PARSTX
	BNE     DELIM1  ;TRY FOR NXT PARAM
;
DOFFH	LDA     #$04
	JSR     PRXRPT
	JSR     GETOFF
	STY     DOSOFH
	STA     DOSOFH+1
	LDA     #$04
	BNE     DLIMX1  ;SET AUX STATUS
;
IDCON
	JSR     CHRGET  ;GET NEXT CHARACTER
	STA     DOSDID  ;M(TXTPTR => DOSDID
	JSR     CHRGET
	STA     DOSDID+1
	LDA     #$FF
	STA     DIDCHK  ;SET DOSDID FLAG &
	JSR     CHRGET  ;CONTINUE
	JMP     DELIM1
.SKIP 4
NAME1
	LDA     #1      ;NAME1 ALLWD ONLY ONCE
	JSR     NEWNAM  ;DO NAME PARSING
	STA     DOSF1L
	STA     XCNT    ;SAVE TEMP VALUE
	LDA     #<FBUFFR
	STA     DOSF1A
	LDA     #>FBUFFR
	STA     DOSF1A+1
	LDA     #SYSBNK ; SET TO SYSTEM BANK
	STA     DOSF1B
;
	LDY     #0
	JSR     MAPINX
LOOP6	LDA (INDEX)Y
	STA     FBUFFR,Y ; SET CHAR IN BUFFER
	INY
	CPY     XCNT
	BCC     LOOP6   ;IF NOT FULL NAME
	JSR     MAPTXT
	LDA     #1      ;SET NAME1 FLAG
;
DEL1
	ORA     PARSTS
	STA     PARSTS
;
DELIM1
	JSR     CHRGOT
	BNE     NXXX
DONE1	JMP     DONE    ;<CR>/<>  => DONE
;
NEXT6	CMP     #TKON
	BNE     NEXT6A
	JMP     ON1
NEXT6A	CMP     #TKTO   ;"TO" TOKEN
	BEQ     NEXT6B
	BNE     SAV61   ;SNTAX ERROR
;
;   IF "TO" IS NOT FOLLOWED BY AN OFFSET PARAM,
;   THEN DO FILE2 PARAMS. OTHERWISE, DO HIGH
;   OFFSET AND CONTINUE WITH FILE0 OPTIONS.
NEXT6B	JSR     CHRGET
	CMP     #'P'
	BNE     PARS22
	BEQ     DOFFH
;
NXXX	CMP     #','
	BNE     NEXT6
	JSR     CHRGET
	JMP     PARSE1
;
PARSE2	JSR     CHRGET
PARS22	CMP     #'D'
	BEQ     DRV2
	CMP     #TKON   ;"ON" TOKEN
	BEQ     ON2
	CMP     #'U'
	BEQ     UNIT2
	CMP     #'"'
	BEQ     NAME2
	CMP     #'('
	BEQ     NAME2
;
DRV2
	LDA     #$20
	JSR     PRMRPT  ;CHECK FOR REPEATED PARAMETER
	JSR     GETVAL
	CPX     #2
	BCS     QTYERR  ;ILLEGAL DRIVE #
	STX     DOSDS2
	LDA     #$20
	BNE     DEL2
;
ON2	JSR     ON
	JMP     DEL2
;
UNIT2	JSR     UNIT    ;DO UNIT# PARSING
	BNE     DEL2    ;ALWAYS
;
NAME2
	LDA     #2      ;NAME2 ALLOWED ONLY ONCE
	JSR     NEWNAM
	STA     DOSF2L
	STX     DOSF2A
	STY     DOSF2A+1
	LDA     INDEX1+2 ; GET STRNG BANK#
	STA     DOSF2B
	LDA     #2      ;SET FILENAME2 FLAG &
;
DEL2
	ORA     PARSTS  ;SET FLAG IN STATUS
	STA     PARSTS
	JSR     CHRGOT
	BEQ     DONE1   ;DONE ON <CR>/<>
	CMP     #','
	BEQ     PARSE2
	CMP     #TKON   ;"ON" TOKEN
	BEQ     ON2
	CMP     #'U'
	BEQ     UNIT2
SAV61
	BNE     SNER
.SKIP 4
QTYERR
	JMP     FCERR   ;"ILLEGAL QUANTITY"
;
ON	JSR     CHRGET
	CMP     #'U'
	BEQ     UNIT    ;IF CHARACTER IS A "U"
	CMP     #'B'
	BEQ     BANK
	BNE     SNER
;
UNIT
	JSR     GETVAL
	CPX     #32
	BCS     QTYERR  ;ERROR IF >31
	CPX     #3
	BCC     QTYERR  ;ERROR IF <3
	STX     DOSFA
	LDA     #8
	RTS
;
BANK
	LDA     #$01    ;REPEATED PARAM?
	JSR     PRXRPT
	JSR     GETVAL
	CPX     #MXBANK ;BANK TOO LARGE?
	BCS     QTYERR
	STX     DOSBNK
	LDA     #$01
	ORA     PARSTX  ;SET BNK BIT IN AUX STATUS
	STA     PARSTX
	LDA     #0      ; .A=STD STATUS WRD, NO BITS TO SET
	RTS
;
SNER	JMP     SNERR   ;JUMP SYSTAN ERROR
;
NEWNAM
	JSR     PRMRPT  ;CHECK FOR REPEATED PARAMETER
	JSR     SAV13
	TAX             ;SAVE LENGTH OF STRING
	BEQ     QTYERR  ;IF LENGTH = 0
	LDY     #0
	JSR     SAV12
	CMP     #'@'
	BNE     LENCHK
	LDA     #$80
	JSR     PRMRPT
	LDA     PARSTS
	ORA     #$80    ;SET "@" FLAG
	STA     PARSTS
	DEX             ;DECREMENT LENGTH
	INC     INDEX1  ;INCREMENT PAST "@"
	BNE     LENCHK  ;IF NO CARRY
	INC     INDEX1+1
;
LENCHK
	TXA
	CMP     #17
	BCS     ERRLEN  ;IF LENGTH < 17
	LDX     INDEX1
	LDY     INDEX1+1
	RTS
;
ERRLEN	LDX     #ERRLS
	JMP     ERROR   ;FILENAME TOO LONG
.SKIP 4
GETVAL	;GET NEXTVALUE ROUTINE
	JSR     CHRGET  ;GET NXT CHR
GTVL2	BEQ     SNER    ;IF END OF STATEMENT
	BCC     GTVL5   ;CAN BE NUMERIC
	JSR     CHKOPN  ;OR A "("
	JSR     GETBYT  ;ANYTHING ELSE IS AN ERROR
	JMP     CHKCLS  ;NEED CLOSING ")"
;
GTVL5	JMP     GETBYT  ;EVALUATE IT
;
;   GET NEXT 2BYTE EXPR ROUTINE
;   EXIT:  .A,.Y (HIGH,LOW) VALUE
;
GETOFF	JSR     CHRGET  ;GET NXT CHR
	BEQ     SNER    ;IF END OF STATEMENT
	BCC     GTFF5   ;CAN BE NUM. CONST
	JSR     CHKOPN  ;OR A "("
	JSR     GETPIN  ;EXPR
	JSR     CHKCLS  ;NEED CLOSING ")"
	LDY     POKER
	LDA     POKER+1
	RTS
;
GTFF5	JMP     GETPIN  ;EVALUATE IT
.SKIP 4
;       PRMRPT  CHECKS FOR A REPEATED PARAMETER.
;
;       ENTRY   A CONTAINS PARSTS FLAG TO CHECK.
PRMRPT
	AND     PARSTS  ;AND WITH PARSTS
	BNE     SNER    ;IF BIT PREVIOUSLY SET
	RTS
;
;       PRXRPT  CHECKS FOR A REPEATED PARAMETER.
;
;       ENTRY   A CONTAINS PARSTX FLAG TO CHECK.
PRXRPT
	AND     PARSTX  ;AND WITH PARSTX
	BNE     SNER    ;IF BIT PREVIOUSLY SET
	RTS
.END
