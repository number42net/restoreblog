.PAGE   'DEFINTION OF BASIC AND PARAMETERS'
; PAGE ZERO ----------------------
;       STARTUP:
;      INITIALLY A JMP TO INITIALIZATION CODE BUT CHANGED TO
;       A JMP TO 'READY'.
;       RESTARTING THE MACHINE AT LOC 0 DURING PROGRAM
;       EXECUTION CAN LEAVE THINGS MESSED UP.
;       LOC OF FAC TO INTEGER AND INTEGER TO FAC ROUTINES
;       'DIRECT' MEMORY.
;       THESE ARE THE MOST COMMONLY USED LOCATIONS.
;       THEY HOLD BOOKKEEPING INFO AND ALL OTHER
;       FREQUENTLY USED INFORMATION.
;       ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
;       THE FLOATING ACCUMULATOR, AND ANYTHING ELSE THAT IS
;       USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
;       IN THIS AREA.  CARE MUST BE MADE IN MOVING LOCATIONS IN
;       THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
;       IS OFTEN DEPENDED UPON.
;
;       STILL IN RAM WE HAVE THE BEGINNING OF THE 'CHRGET'
;       SUBROUTINE.  IT IS HERE SO [TXTPTR] CAN BE THE
;       EXTENDED ADDRESS OF A LOAD INSTRUCTION.
;       THIS SAVES HAVING TO BOTHER ANY REGISTERS.
.SKIP 4
; PAGE ONE -----------------------
;       THE STACK
.PAGE
; STORAGE, PAGE TWO AND ON--------
;       IN RAM VERSIONS THESE DATA STRUCTURES COME AT THE END
;       OF BASIC.  IN ROM VERSION THEY ARE AT RAMLOC WHICH CAN
;       EITHER BE ABOVE OR BELOW ROMLOC, WHICH IS WHERE BASIC
;       ITSELF RESIDES.
; TXTTAB
;       POINTER TO NEXT LINE'S POINTER.  LINE # OF THIS (2 BYTES)
;       CHARACTERS ON THIS LINE.
;       ZERO, POINTER AT NEXT LINE'S POINTER (POINTED TO BY THE
;       ABOVE POINTER).
;       ..REPEATS
; LASTLINE:
;       POINTER AT ZERO POINTER.  LINE # OF THIS LINE.
;       CHARACTERS ON THIS LINE.
;       ZERO
;       DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER).
; VARTAB:
;       SIMPLE VARIABLES.  6 BYTES PER VALUE.
;       2 BYTES GIVE THE NAME, 4 BYTES THE VALUE.
;       ..REPEATS.
; ARYTAB:
;       ARRAY VARIABLES.  2 BYTES NAME. 2 BYTE LENGTH, NUMBER
;       OF DIMENSIONS, EXTENT OF EACH DIMENSION (2BYTES),
;       VALUES.
;       ..REPEATS.
; STREND:
;       FREE SPACE.
;       ..REPEATS.
; FRETOP:
;       STRING SPACE IN USE.
;       ..REPEATS.
; MEMSIZ:
;       HIGHEST MACHINE LOCATION.  UNUSED EXCEPT BY THE VAL
;       FUNCTION.
.PAGE
;       ROM CONSTANTS AND CODE.
; FUNCTION DISPATCH ADDRESSES (AT ROMLOC)
;       FUNSP CONTAINS THE ADDRESSES OF THE FUNCTION ROUTINES
;       IN THE ORDER OF THE FUNCTION NAMES IN THE CRUNCH LIST.
;       THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT ARE
;       AT THE END.  SEE THE EXPLANATION AT ISFUN.
;
; THE OPERATOR LIST
;       THE OPTAB LIST CONTAINS AN OPERATOR'S PRECEDENCE
;       FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
;       THE OPERATION.  THE INDEX INTO THE OPERATOR LIST
;       IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
;       OF THE LOWEST NUMBERED OPERATOR.  THE ORDER OF
;       OPERATORS IN THE CRUNCH LIST AND IN OPTAB IS IDENTICAL
;       THE PRECEDENCES ARE ARBITRARY EXCEPT FOR THEIR
;       COMPARATIVE SIZES.  NOTE THAT THE PRECEDENCE FOR UNARY
;       OPERATORS SUCH AS NOT AND NEGATION ARE SETUP
;       SPECIALLY WITHOUT USING THE LIST.
;
; THE RESERVED WORD OR CRUNCH LIST
;       WHEN A COMMAND OR PROGRAM LINE IS TYPED IN IT IS
;       STORED IN BUF.  AS SOON AS THE WHOLE LINE HAS BEEN
;       TYPED IN (INLIN RETURNS) CRUNCH IS CALLED TO CONVERT
;       ALL RESERVED WORDS TO THEIR CRUNCED VALUES.   THIS
;       REDUCES THE SIZE OF THE PROGRAM AND SPEEDS UP
;       EXECUTION BY ALLOWING LIST DISPATCHES TO PERFORM
;       FUNCTIONS, STATEMENTS, AND OPERATIONS.  THIS IS
;       BECAUSE ALL THE STATMENT NAMES ARE STORED CONSECUTIVELY
;       IN THE CRUNCH LIST.
;       WHEN A MATCH IS FOUND BETWEEN A STRING OF CHARS AND
;       A WORD IN THE CRUNCH LIST THE ENTIRE TEXT OF THE
;       MATCHED WORD IS TAKEN OUT OF THE INPUT LINE AND A
;       RESERVED WORD TOKEN IS PUT IN ITS PLACE.  A RESERVED
;       WORD TOKEN IS ALWAYS EQUAL TO 200Q (80H) PLUS THE
;       POSITION OF THE MATCHED WORD IN THE CRUNCH LIST.
;
; STATEMENT DISPATCH ADDRESSES
;       WHEN A STATMENT IS TO BE EXECUTED, THE 1ST CHAR OF
;       THE STATMENT IS EXAMINED TO SEE IF IT IS < THE
;       RESERVED WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT
;       NAME.
;       IF SO, THE LET CODE IS CALLED TO TREAT THE STATMENT
;       AS AN ASSIGNMENT STATEMENT, OTHERWISE
;       A CHECK IS MADE TO MAKE SURE THE RESERVED WORD # IS
;       NOT TOO LARGE TO BE A STATEMENT TYPE #.  IF NOT THE
;       ADDRES TO DISPATCH TO IS FETCHED FROM STMDSP USING
;       THE RESERVED WORD NUMBER FOR THE STATMENT TO CALC
;       AN INDEX INTO THE LIST.
;
; ERROR MESSAGES
;       WHEN AN ERROR CONDITION IS DETECTED, ACCX MUST BE SET
;       UP TO INDICATE WHICH ERROR MESSAGE IS APPROPIATE AND
;       A BRANCH MUST BE MADE TO ERROR.  THE STK WILL BE RESET
;       AND ALL PROGRAM CONTEXT WILL BE LOST.  VARIABLES
;       VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.  ONLY THE
;       VALUE OF ACCX IS IMPORTANT WHEN THE BRANCH IS MADE TO
;       ERROR.  ACCX IS USED AS AN INDEX INTO ERRTAB WHICH GIVES
;       THE TWO CHAR ERROR MESSAGE THAT WILL BE PRINTED ON THE
;       USER'S TERMINAL.
;
; TEXTUAL MESSAGES
;       CONSTANT MESSAGES ARE STORED HERE.  UNLESS THE CODE TO
;       CHECK IF A STR MUST BE COPIED IS CHANGED THESE STRS
;       MUST BE STORED ABOVE PAGE ZERO, OR ELSE THEY WILL BE
;       COPIED BEFORE THEY ARE PRINTED.
;
; FNDFOR
;       MOST SMALL ROUTINES ARE FAIRLY SIMPLE AND ARE DOCUMENTED
;       IN PLACE.  FINFOR IS USED FOR FINDING FOR ENTRIES ON THE
;       STK.  WHENEVER A FOR IS EXECUTED, A 16 BYTE ENTRY IS PUSHED
;       ON THE STK.  BEFORE THIS IS DONE, HOWEVER, A CHECK MUST
;       BE MADE TO SEE IF THERE ARE ANY FOR ENTRIES ALREADY
;       ON THE STK FOR THE SAME LOOP VARIABLE.  IF SO, THAT FOR
;       ENTRY AND ALL OTHER FOR ENTRIES THAT WERE MADE AFTER IT
;       ARE ELIMINATED FROM THE STK.  THIS IS SO A PROGRAM THAT
;       JUMPS OUT OF THE MIDDLE OF A FOR LOOP AND THEN RESTARTS
;       THE LOOP AGAING AND AGAIN WON'T USE UP 16 BYTES OF STK
;       SPACE EVERY TIME.  THE NEXT CODE ALSO CALLS FNDFOR TO
;       SEARCH FOR A FOR ENTRY WITH THE LOOP VARIABLE IN THE
;       NEXT.  AT WHATEVER POINT A MATCH IS FOUND THE STK IS
;       RESET.  IF NO MATCH IS FOUND A NEXT WITHOUT FOR ERROR
;       OCCURS.
; GOSUB
;       GOSUB EXECUTION ALSO PUTS A 5 BYTE ENTRY ON THE STK.
;       WHEN A RETURN IS EXECUTED FNDFOR IS CALLED WITH A
;       VARIABLE POINTER THAT CAN'T BE MATCHED.  WHEN FNDFOR
;       HAS RUN THROUGH ALL THE FOR ENTRIES ON THE STK IT
;       RETURNS AND THE RETURN CODE MAKES SURE THE ENTRY THAT
;       WAS STOPPED ON IS A GOSUB ENTRY.  THIS ASSURES THAT IF
;       YOU GOSUB TO A SECTION OF CODE IN WHICH A FOR LOOP IS
;       ENTERED BUT NEVER EXITED THE RETURN WILL STILL BE
;       ABLE TO FIND THE MOST RECENT GOSUB ENTRY.  THE RETURN
;       CODE ELIMINATES THE GOSUB ENTRY AND ALL FOR ENTRIES
;       MADE AFTER THE GOSUB ENTRY.
;
; NON-RUNTIME STUFF
;       THE CODE TO INPUT A LINE, CRUNCH IT, GIVE ERRORS,
;       FIND A SPECIFIC LINE IN THE PROGRAM, PERFORM A
;       NEW, CLEAR, AND LIST ARE ALL IN THIS AREA.  GIVEN
;       THE EXPLANATION OF PROGRAM STORAGE SET FORTH ABOVE,
;       THESE ARE ALL STRAIGHT-FORWARD....
;
; NEWSTT
;       WHENEVER A STATEMENT FINISHES EXECUTION IT DOES A
;       RTS WHICH TAKES EXECUTION BACK TO NEWSTT.  STATEMENTS
;       THAT CREATE OR LOOK AT SEMI-PERMANENT STK ENTRIES
;       MUST GET RID OF THE RET ADR OF NEWSTT AND JMP TO
;       NEWSTT WHEN DONE.  NEWSTT ALWAYS CHRGETS THE 1ST
;       CHARACTER AFTER THE STATEMENT NAME BEFORE DISPATCHING.
;       WHEN RETURNING BACK TO NEWSTT THE ONLY THING THAT MUST
;       BE SET UP IS THE TEXT POINTER IN TXTPTR.  NEWSTT WILL
;       CHEKC TO MAKE SURE TXTPTR IS POINTING TO A STATMENT
;       TERMINATOR.  IF A STATMENT SHOULDN'T BE PERFORMED UNLESS
;       IT IS PROPERLY FORMATTED (IE. NEW) IT CAN SIMPLY DO
;       A RETURN AFTER READING ALL OF ITS ARGUMENTS.  SINCE
;       THE ZERO FLAG BEING OFF INDICATES THERE IS NOT A
;       STATMENT TERMINATOR NEWSTT WILL DO THE JMP TO THE
;       SYNTAX ERROR ROUTINE.  IF A STATEMENT SHOULD BE STARTED
;       OVER IT CAN DO  LDWD OLDTXT
;                       STWD TXTPTR
;                       RTS
;       SINCE THE EXT POINTER AT NEWSTT IS ALWAYS STORED IN
;       OLDTXT.
;
; STATEMENT CODE
;       THE INDIVIDUAL STATMENT CODE COMES NEXT.  THE APPROACH
;       USED IN EXECUTING EACH STATEMENT IS DOCUMENTED IN THE
;       STATEMENT CODE ITSELF.
;
; FRMEVL, THE FORMULA EVALUATOR.
;       GIVEN A TEXT PTR POINTING TO THE STARTING CHAR OF A
;       FORMULA AND LEAVES THE VALUE IN THE FLOATING ACC (FAC).
;       TXTPTR IS RETURNED POINTING TO THE 1ST CHAR THAT COULD
;       NOT BE INTERPRETED AS PART OF THE FORMULA.  THE ALGO
;       USES THE STK TO STORE TEMP RESULTS:
;       0.  PUT A DUMMY PRECEDENCE OF ZERO ON THE STK.
;       1.  READ LEXEME (CONSTANT, FUNCTION, VARIABLE, FORMULA
;           IN PARENS) AND TAKE THE LAST PRECEDENCE VALUE OFF
;           OF THE STK.
;       2.  SEE IF THE NEXT CHAR IS AN OPERATOR.  IF NOT, CHECK
;           PREVIOUS ONE.  THIS MAY CAUSE OPERATOR APPLICATION
;           OR AN ACTUAL RETURN FROM FRMEVL.
;       3.  IF IT IS, SEE WHAT PRECEDENCE IT HAS AND COMPARE IT
;           TO THE PRECEDENCE OF THE LAST OPERATOR ON THE STK.
;       4.  IF = OR < REMEMBER THE OPERATOR POINTER OF THIS
;           OPERATOR AND BRANCH TO QCHNUM TO CAUSE APPLICATION
;           OF THE LAST OPERATOR.  EVENTUALLY RETURN TO STEP 2
;           BY RETRUNING TO JUST AFTER DOPREC
;       5.  IF > PUT THE LAST PRECEDENCE BACK ON, SAVE THE
;           OPERATOR ADR, CURRENT TEMP RESULT, AND PRECEDENCE
;           AND RETURN TO STEP 1.
;       RELATIONAL OPERATORS ARE ALL HANDLED THROUGH A COMMON
;       ROUTINE.  SPECIAL CARE IS TAKEN TO DETECT TYPE MISMATCHES
;       SUCH AS 3+"F".
;
; EVAL - THE ROUTINE TO READ A LEXEME
;       EVAL CHECKS FOR THE DIFFERENT TYPES OF ENTITIES IT IS
;       SUPPOSED TO DETECT.  LEADING PLUSES ARE IGNORED.
;       DIGITS AND '.' CAUSE FIN (FLOATING INPUT) TO BE
;       CALLED.  FUNCTION NAMES CAUSE THE FORMULA INSIDE THE
;       ()S TO BE EVAULUATED AND THE FUNTION ROUTINE TO BE
;       CALLED.  VARIABLE NAMES CAUSE PTRGET TO BE CALLED TO
;       GET A -> TO THE VALUE, AND THEN THE VALUE IS PUT
;       INTO THE FAC.  AN OPERN PAREN CAUSES FRMEVL TO BE
;       CALLED (RECURSIVELY).  AND A ) TO BE CHECKED FOR.
;       UNARY OPERS (NOT AND NEGATION) PUT THEIR PRECEDENCE
;       ON THE STK AND ENTER FORMULA EVALUATION AT STEP 1, SO
;       THAT EVERYTHING UP TO AN OPERATOR > THEIR PRECEDENCE
;       OR THE END OF THE FORMULA WILL BE EVALUATED.
;
; DIMENSION AND VARIABLE SEARCHING
;       SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
;       ENCOUNTERED.  THUS DIM STATEMENTS MUST BE EXECUTED
;       TO HAVE EFFECT.  6 BYTES ARE ALLOCATED FOR EACH SIMPLE
;       VARIABLE, WHETHER IT IS A STRING, NUMBER OR USER DEFINED
;       FUNCTION.  THE 1ST TWO BYTES GIVE THE NAME OF THE VAR
;       AND THE LAST FOUR GIVE ITS VALUE.  VARTAB GIVES THE 1ST
;       LOCATION WHERE A SIMPLE VAR NAME IS FOUND AND ARYTAB
;       GIVES THE LOC TO STOP SEARCHING FOR SIMPLE VARS.  A FOR
;       ENTRY HAS A TEXT POINTER AND A POINTER TO A VAR VALUE
;       SO NEITHER THE PROGRAM OR THE SIMPLE VAR CAN BE MOVED
;       WHILE THERE ARE ACTIVE FOR ENTRIES ON THE STK.  USER
;       DEFINED FUNCTION VALUES ALSO CONTAIN POINTERS INTO A
;       SIMPLE VARIABLE SPACE SO NO USER-DEFINED FUNCTION VALUES
;       CAN BE RETAINED IF SIMPLE VARIABLES ARE MOVED.  ADDING
;       A SIMPLE VAR IS JUST ADDING SIXE TO ARYTAB AND STREND,
;       BLOCK TRANSFERING THE ARRAY VARIABLES UP BY 6 AND
;       MAKING SURE THE STREND IS NOT TOO CLOSE TO THE STRINGS.
;       THIS MOVEMENT OF ARRAY VARIABLES MEANS THAT NO POINTER
;       TO AN ARRAY WILL STAY VALID WHEN NEW SIMPLE VARS CAN
;       BE ENCOUNTERED.  THIS IS WHY ARRAY VARS ARE NOT ALLOWED
;       FOR FOR LOOP VARS.  SETTING UP A NEW ARRAY VAR MERELY
;       INVOLVES BUILDING THE DESCRIPTOR, UPDATING STREND, AND
;       MAKING SURE THERE IS STILL ENOUGH ROOM BETWEEN STREND
;       AND STRING SPACE.  PTRGET, THE ROUTINE WHICH RETURNS
;       A POINTER TO A VAR VALUE, HAS TWO IMPORTANT FLAGS.
;       ONE IS DIMFLG WHICH INDICATES WHETHER DIM CALLED PTRGET
;       OR NOT.  IF SO, NO PRIOR ENTRY FOR THE VAR IN QUESTION
;       SHOULD BE FOUND, AND THE INDEX INDICATES HOW MUST SPACE
;       TO SET ASIDE.  SIMPLE VARS CAN BE DIMENSIONED, BUT
;       THE ONLY EFFECT WILL BE TO SET ASIDE SPACE FOR THE
;       VAR IF IT HASN'T BEEN ENCOUNTERED YET.
;       THE OTHER IMPORTANT FLAG IS SUBFLG WHICH INDICATES
;       WHETHER A SUBSCRIPTED VAR SHOULD BE ALLOWED IN THE
;       CURRENT CONTEXT.  IF SUBFLG IS NON-ZERO THE OPEN
;       PARENTESIS FOR A SUBSCRIPTED VAR WILL NOT BE SCANNED
;       BY PTRGET, AND PTRGET WILL RETURN WITH A TEXT POINTER
;       TO THE '(', IF THERE WAS ONE.
.SKIP 4
; STRINGS
;       IN THE VARIABLE TABLES STRINGS ARE STORED JUST LIKE
;       NUMERIC VARIABLES.  SIMPLE STRINGS HAVE THREE VALUE BYTES
;       WHICH ARE INITIALIZED TO ALL ZEROS (WHICH REPS THE
;       NULL STRING).  THE ONLY DIFFERENCE IN HANDLING IS THAT
;       WHEN PTRGET SEES A $ AFTER THE NAME OF A VAR, PTRGET
;       SETS VALTYP TO NEGATIVE ONE AND TURNS ON THE MSB
;       OF THE VALUE OF THE 1ST CHAR OF THE VARIABLE NAME.
;       HAVING THIS BIT ON IN THE NAME OF THE VAR ENSURES
;       THAT THE SEARCH ROUTINE WILL NOT MATCH 'A' OR 'A$'
;       WITH 'A'.  THE MEANING OF THE THREE VALUE BYTES ARE:
;               LOW
;               LENGTH OF STRING
;               LOW 8 BITS
;               HIGH 8 BITS OF THE ADDRESS OF THE CHAR IN
;               THE STRING IF LEN <> 0.
;               MEANINGLESS OTHERWISE
;               HIGH
;       THE VALUE OF A STRING VAR (THESE 3 BYTES) IS CALLED
;       THE STRING DESCRIPTOR TO DISTINGUISH IT FROM THE
;       ACTUAL STRING DATA.  WHENEVER A STRING CONSTANT IS
;       ENCOUNTERED IN A FORMULA OR AS PART OF AN INPUT
;       STING, OR AS PART OF DATA, STRLIT IS CALLED, CAUSING
;       A DESCRIPTOR TO BE BUILT FOR THE STRING.  WHEN
;       ASSIGNMENT IS MADE TO A STRING POINTING INTO BUF THE
;       VALUE IS COPIED INTO STRING SPACE SING BUF IS
;       ALWAYS CHANGING.
;       ---MORE---
.SKIP 4
; MATH PACKAGE
;       THE MATH PACKAGE CONTAINS FLOATING INPUT FIN, OUTPUT
;       FOUT, COMPARE FCOMP...AND ALL THE NUMERIC OPERATORS
;       AND FUNCTIONS.  THE FORMATS, CONVENTIONS AND ENTRY
;       POINTS ARE ALL DESCRIBED IN THE MATH PACKAGE ITSELF.
;       (HA,HA...)
.SKIP 4
; INIT - THE INITIALIZATION ROUTINE.
;       THE AMOUNT OF MEMORY, THE TERMINAL WIDTH, AND WHICH
;       FUNCTIONS TO BE RETAINED ARE ASCERTAINED FROM THE
;       USER.  A ZERO IS PUT DOWN AT THE 1ST LOC NOT USED BY
;       THE MATH-PACKAGE AND TXTTAB IS SETUP TO POINT AT THE
;       NEXT LOCATION.  THIS DETERMINES WHERE PROGRAM STORAGE
;       WILL START.  SPECIAL CHEKCS ARE MADE TO MAKE SURE ALL
;       QUESTIONS IN INIT ARE ANSWERED REASONABLY, SINCE ONCE
;       INIT FINISHES, THE LOCATIONS IT USES ARE USED FOR
;       PROGRAM STORAGE.  THE LAST THING INIT DOES IS CHANGE
;       LOCATION ZERO TO BE A JUMP TO READY INSTEAD OF INIT.
;       ONCE THIS IS DONE THERE IS NO WAY TO RESTART INIT.
.END
