.PAG 'BWSUBS 11/12/82'
;  WRAP TABLE SUBROUTINES
;
GETBIT
	LDX TBLX
GETBT1
	JSR BITPOS      ;GET BYTE & BIT POSITIONS
	AND BITABL,X
	CMP #1          ;MAKE CARRY CLEAR IF ZERO
	JMP BITOUT
;
; PUTBIT - SET BIT ACCORDING TO CARRY
;
PUTBIT
	LDX TBLX
PUTBT1
	BCS SETBIT      ;GO IF TO MARK AS WRAPPPED LINE
;
; CLRBIT - CLEAR WRAP BIT
;
CLRBIT
	JSR BITPOS      ;GET BYTE & BIT POSITIONS
	EOR #$FF        ;INVERT BIT POSITION
	AND BITABL,X    ;CLEAR BIT
BITSAV
	STA BITABL,X
BITOUT
	LDX BITMSK
	RTS
;
; SETBIT  -  SET BIT TO MARK AS WRAPPED LINE
;
SETBIT
	JSR BITPOS      ;GET BYTE & BIT POSITION
	ORA BITABL,X    ;SET WRAP BIT
	BNE BITSAV      ;ALWAYS
;
; BITPOS - GET BYTE & BIT POSITION OF WRAP BIT
;          INPUT - X = ROW NUMBER
;          OUTPUT - X = BYTE NUMBER
;                   A = BIT MASK
;
BITPOS
	STX BITMSK
	TXA
	AND #$07        ;GET BIT POSITION
	TAX
	LDA BITS,X      ;GET BIT MASK
	PHA
	LDA BITMSK
	LSR A
	LSR A           ;SHIFT TO GET BYTE POSITION
	LSR A
	TAX
	PLA
	RTS
.SKI 3
;**********************************
;  MOVE TO START OF LINE
;
FNDFST
	LDY SCLF
	STY PNTR        ;SET TO LEFTMOST COLUMN
;
FISTRT
	JSR GETBIT      ;FIND START OF CURRENT LINE
	BCC FND0        ;BRANCH IF FOUND
	DEC TBLX        ;UP A LINE
	BPL FISTRT      ;ALWAYS
	INC TBLX        ;WHOOPS WENT TOO FAR
FND0
	JMP STUPT       ;SET LINE BASE ADR
.SKIP 3
; ****** FIND LAST NON-BLANK CHAR OF LINE
;
; PNTR= COLUMN #
; TBLX= LINE #
;
FNDEND	INC TBLX
	JSR GETBIT      ;IS THIS LINE CONTINUED
	BCS FNDEND      ;BRANCH IF SO
	DEC TBLX        ;FOUND IT - COMPENSATE FOR INC TBLX
	JSR STUPT
	LDY SCRT        ;GET RIGHT MARGIN
	STY PNTR        ;POINT TO RIGHT MARGIN
	BPL ELOUP2      ;ALWAYS
;
ELOUP1	JSR BAKCHR
	BCS ENDBYE      ;IF AT TOP LEFT GET OUT
ELOUP2	JSR GET1CH
	CMP #$20
	BNE ENDBYE      ;YES
	CPY SCLF        ;ARE WE AT THE LEFT MARGIN?
	BNE ELOUP1      ;BRANCH IF NOT
	JSR GETBIT      ;IF WE'RE ON A WRAPED LINE
	BCS ELOUP1      ; ALWAYS SCAN THE ABOVE LINE
;
ENDBYE
	STY INDX        ;REMEMBER THIS
	RTS
.SKIP 3
; ****** MOVE TO NEXT CHAR
; SCROLL IF ENABLED
; WRAP TO TOP IF DISABLED
;
NXTCHR
	PHA
	LDY PNTR
	CPY SCRT        ;ARE WE AT THE RIGHT MARGIN?
	BCC BUMPNT      ;BRANCH IF NOT
.SKI
	JSR NXLN        ;POINT TO NEXTLINE
	LDY SCLF        ;POINT TO FIRST CHAR OF 1ST LINE
	DEY
	SEC             ;SET TO SHOW MOVED TO NEW LINE
BUMPNT	INY             ;INCREMENT CHAR INDEX
	STY PNTR
	PLA
	RTS
.SKIP 3
; ****** BACKUP ONE CHAR
; WRAP UP AND STOP A TOP LEFT
;
BAKCHR
	LDY PNTR
	DEY
	BMI BAKOT1
	CPY SCLF        ;ARE WE AT THE LEFT MARGIN
	BCS BAKOUT      ;NO - PAST IT
BAKOT1
	LDY SCTOP
	CPY TBLX        ;ARE WE AT TOP LINE LAST CHARACTER?
	BCS BAKOT2      ;LEAVE WITH CARRY SET
	DEC TBLX        ;ELSE BACKUP A LINE
	PHA
	JSR STUPT       ;SET LINE BASE ADR
	PLA
	LDY SCRT        ;MOVE CURSOR TO RIGHT SIDE
BAKOUT
	STY PNTR
	CPY SCRT        ;SET Z-FLAG IF MOVED TO NEW LINE
	CLC             ;ALWAYS CLEAR
BAKOT2	RTS
.SKI 3
;  SAVPOS - SAVE ROW & COLUMN POSITION
;
SAVPOS
	LDY PNTR
	STY SEDT1
	LDX TBLX
	STX SEDT2
	RTS
.PAG
DELINS
	BCS INSERT
.SKI
; DELETE A CHARACTER
;
DELEET
	JSR CLEFT       ;MOVE BACK 1 POSITION
	JSR SAVPOS      ;SAVE COLUMN & ROW POSITIONS
	BCS DELOUT      ;ABORT IF AT TOP LEFT CORNER
DELOOP
	CPY SCRT        ;AT RIGHT MARGIN?
	BCC DELOP1      ;NO - SKIP AHEAD
	LDX TBLX
	INX
	JSR GETBT1      ;IS NEXT LINE A WRAPPED LINE?
	BCS DELOP1      ;YES - CONTINUE WITH DELETE
	JSR DOBLNK      ;NO - BALNK LAST CHARACTER
DELOUT
	LDA SEDT1       ;RESTORE COLUMN AND ROW POSITIONS
	STA PNTR
	LDA SEDT2
	STA TBLX
	JMP STUPT       ;RESTORE PNT AND EXIT
DELOP1
	JSR NXTCHR
	JSR GET1CH      ;GET NEXT CHARACTER
	JSR BAKCHR
	JSR DSPP        ;MOVE IT BACK 1 POSITION
	JSR NXTCHR      ;MOVE UP 1 POSITION
	JMP DELOOP      ;LOOP UNTIL AT END OF LINE
.SKI 3
; INSERT A CHARACTER
;
INSERT
	JSR SAVPOS      ;SAVE COLUMN & ROW POSITIONS
	JSR FNDEND      ;MOVE TO LAST CHAR ON THE LINE
	CPX SEDT2       ;LAST ROW EQUAL TO STARTING ROW?
	BNE INS10       ;NO - SKIP AHEAD
	CPY SEDT1       ;IS LAST POSITION BEFORE STARTING POSITION?
INS10
	BCC INS50       ;YES - NO NEED TO MOVE ANYTHING
	JSR MOVCHR      ;MOVE TO NEXT CHAR POSITION
	BCS INSOUT      ;ABORT IF SCROLL NEEDED BUT DISABLED
INS30
	JSR BAKCHR
	JSR GET1CH      ;MOVE CHAR FORWARD 1 POSITION
	JSR NXTCHR
	JSR DSPP
	JSR BAKCHR
	LDX TBLX
	CPX SEDT2       ;AT ORIGINAL POSITION
	BNE INS30
	CPY SEDT1
	BNE INS30       ;NO - LOOP TILL WE ARE
	JSR DOBLNK      ;INSERT A BLANK
INS50
	INC INSRT       ;INC INSERT COUNT
	BNE INSOUT      ;ONLY ALLOW UP TO 255
	DEC INSRT
INSOUT
	JMP DELOUT      ;RESTORE ORIGINAL POSITION
.SKI 3
;
;  STOP/RUN
;
STPRUN
	BCC RUNRTS      ;EXIT IF A STOP CODE
	SEI             ;DISABLE INTERRUPTS
	LDX #9
	STX NDX         ;SET KEYBOARD QUEUE SIZE
RUNLOP
	LDA RUNTB-1,X
	STA KEYD-1,X    ;LOAD RUN CHARACTER SEQUENCE INTO KYBD QUEUE
	DEX
	BNE RUNLOP
	CLI             ;ENABLE INTERRUPTS
RUNRTS
	RTS
.SKI 3
;  MOVCHR  -  MOVE TO NEXT CHAR POSITION
;             INSERT BLANK LINE IF AT END OF LINE
;             Y = COLUMN POSITION
;              ON EXIT - CARRY SET = ABORT - SCROLL DISABLED
;
MOVCHR
	CPY SCRT
	BCC MOVC10      ;EASY IF NOT AT END OF LINE
	LDX TBLX
	CPX SCBOT
	BCC MOVC10      ;SKIP IF NOT LAST LINE OF SCREEN
	BIT SCRDIS
	BMI MOVC30      ;ABORT IF SCROLLING DISABLED
MOVC10
	JSR STUPT       ;SET PNT ADDRESS
	JSR NXTCHR      ;MOVE TO NEXT CHAR POSITION
	BCC MOVC30      ;DONE IF NOT MOVE TO NEW LINE
	JSR GETBIT      ;CHECK IF ON A CONTINUED LINE
	BCS MOVC20      ;SKIP AHEAD IF NOT
	JSR SCRDWN      ;ELSE INSERT A BLANK LINE
MOVC20
	CLC             ;FOR CLEAN EXIT
MOVC30
	RTS
.SKI 2
.END
