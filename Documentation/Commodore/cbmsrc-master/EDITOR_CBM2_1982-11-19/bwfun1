.PAG 'FUNCS1 11/17/82'
; *** PRINT A CHAR ***
;
;
PRT	PHA
	CMP #$FF
	BNE PRT10
	LDA #$DE        ;CONVERT PI CHARACTER
PRT10
	STA DATA        ;SAVE CHAR
	TXA             ;SAVE REGS.
	PHA
	TYA
	PHA
	LDA #0
	STA CRSW
	LDY PNTR        ;COLUMN WE ARE IN
	LDA DATA
	AND #$7F
	CMP #$20        ;TEST IF CONTROL CHARACTER
	BCC NTCN        ;YES
	LDX LSTCHR      ;WAS LAST CHAR AN ESC
	CPX #$1B
	BNE NJT10       ;NO
	JSR SEQUEN      ;YES - DO ESC SEQUENCE
	JMP GETOUT
NJT10
	AND #$3F        ;NO - MAKE A SCREEN CHAR
NJT20
	BIT DATA
	BPL NJT30       ;SKIP AHEAD IF NORMAL SET - 00 - 3F
	ORA #$40        ; CONVERT A0 - BF TO 60 - 7F & C0 - DF TO 40 - 5F
NJT30
	JSR QTSWC       ;TEST FOR QUOTE
	JMP NXT3        ;PUT ON SCREEN
.SKIP 3
; ********* CONTROL KEYS *********
;
NTCN
	CMP #$0D        ;TEST IF A RETURN
	BEQ NTCN20      ;NO INVERSE IF YES
	CMP #$14        ;TEST IF INSERT OR DELETE
	BEQ NTCN20      ;ALLOW IN INSERT OR QUOTE MODE
	CMP #$1B        ;TEST IF ESCAPE KEY
	BNE NTCN1
	BIT DATA
	BMI NTCN1       ;ITS A $9B
	LDA QTSW        ;TEST IF IN QUOTE MODE
	BEQ NTCN20      ;IF NOT, GO EXECUTE REMAINING CODE
	JSR TOQM        ;ELSE GO TURN OFF ALL MODES
	STA DATA        ;AND FORGET ABOUT THIS CHARACTER
	BEQ NTCN20      ;ALWAYS
NTCN1	CMP #$03        ;TEST IF A RUN/LOAD OR STOP
	BEQ NTCN20      ;NO INVERSE IF YES
	LDY INSRT       ;TEST IF IN INSERT MODE
	BNE NTCN10      ;GO REVERSE - IF YES
	LDY QTSW        ;CHECK FOR QUOTE MODE
	BEQ NTCN20      ;DO NOT REVERSE IF NOT
NTCN10
	ORA #$80        ;MAKE REVERSE
	BNE NJT20
.SKI
NTCN20
	LDA DATA
	ASL A           ;SET CARRY IF SHIFTED CTRL
	TAX
	JSR CTDSP       ;INDIRECT JSR
GETOUT
	JMP LOOP2
;
CTDSP	LDA CTABLE+1,X  ;HI BYTE
	PHA
	LDA CTABLE,X    ;LOW BYTE
	PHA
	LDA DATA
	RTS             ;INDIRECT JMP
.SKIP 3
;
CUSER	JMP (CTLVEC)
.SKIP 3
; CURSOR DOWN/UP
;
CDNUP	BCS CUP         ;CURSOR UP
;
CDWN	JSR NXLN        ;CURSOR DOWN
CDN10	JSR GETBIT      ;A WRAPPED LINE ?
	BCS CDRTS       ;SKIP IF YES
	SEC             ;FLAG WE LEFT LINE
	ROR LSXP
CDRTS
	CLC
	RTS
;
CUP	LDX SCTOP       ;CURSOR UP
	CPX TBLX        ;AT TOP OF WINDOW ?
	BCS CRITGO      ; YES - DO NOTHING
CUP10	JSR CDN10       ;ABOUT TO WRAP TO A NEW LINE ?
	DEC TBLX        ;UP A LINE
	JMP STUPT
.SKIP 3
; CURSOR RIGHT/LEFT
;
CRTLF	BCS CLEFT       ;CURSOR LEFT
;
CRIT	JSR NXTCHR      ;CURSOR RIGHT
	BCS CDN10       ;YES - TEST FOR WRAP
CRITGO
	RTS
;
CLEFT	JSR BAKCHR      ;MOVE BACK
	BCS CRITGO      ;ABORT IF AT TOP LEFT
	BNE CDRTS       ;NO - EXIT
	INC TBLX
	BNE CUP10       ;GO SET FLAG IF NEEDED
.SKIP 3
; RVS ON/OFF
;
RVSF	EOR #$80
	STA RVS
	RTS
.SKIP 3
; HOME/CLEAR
;
HOMCLR	BCC HOMES       ;HOME
	JMP CLSR        ;CLEAR SCREEN
;
HOMES	CMP LSTCHR      ;LAST CHAR A HOME ?
	BNE HM110       ;NO
	JSR SRESET      ;TOP=0,LEFT=0,BOT=NROWS-1,RT=COLS-1
HM110	JMP NXTD        ;SET TO TOP LEFT
.SKIP 3
; TAB FUNCTION
;
TABIT
	LDY PNTR
	BCS TABTOG      ; A TAB TOGGLE
TAB1	CPY SCRT        ;AT RIGHT OF WINDOW
	BCC TAB2        ;NO - TAB TO NEXT
	LDA SCRT        ;SET TO SCREEN RIGHT
	STA PNTR
	RTS
;
TAB2	INY             ;FIND NEXT TAB STOP
	JSR GETTAB
	BEQ TAB1        ;NOT YET !
	STY PNTR
	RTS
.SKIP 2
TABTOG
	JSR GETTAB      ;FLIP TAB STOP
	EOR BITMSK
	STA TAB,X
	RTS
.SKIP 3
;
; SKIP TO NEXT LINE
; WRAP TO TOP IF SCROLL DISABLED
;
NXLN
	LDX TBLX
	CPX SCBOT       ;OF THE BOTTOM OF WINDOW ?
	BCC NXLN1       ;NO
	BIT SCRDIS      ;WHAT IF SCROLLING IS DISABLED?
	BPL DOSCRL      ;BRANCH IF SCROLL IS ENABLED
	LDA SCTOP       ;WRAP TO TOP
	STA TBLX
	BCS NOWHOP      ;ALWAYS
;
DOSCRL
	JSR SCRUP       ;SCROLL IT ALL
	CLC             ;INDICATE SCROLL OK
NXLN1	INC TBLX
NOWHOP	JMP STUPT       ;SET LINE BASE ADR
.SKIP 3
; A RETURN OR SHIFT RETURN
;
NXT1	JSR FNDEND      ;FIND THE END OF THE CURRENT LINE
	INX
	JSR CLRBIT      ;SET NEXT LINE AS NON-CONTINUED
	LDY SCLF        ;ELSE POINT TO START OF NEXT LINE
	STY PNTR
	JSR NXLN        ;SET UP NEXT LINE
	LDA #0
	STA INSRT       ;CLEAR INSERTS
	STA RVS         ;CLEAR RVS FIELD
	STA QTSW        ;CLEAR QUOTE MODE
	RTS
.SKIP 5
; ****** SCROLL ROUTINES ******
;
.SKIP 2
; MOVE ONE LINE
;
MOVLIN
	LDA LDTB2,X
	STA SEDSAL
	LDA LDTB1,X
	STA SEDSAL+1
	JSR PAGSET      ;SET TO ROM PAGE
MOVL10
	LDA (SEDSAL),Y
	STA (PNT),Y
	CPY SCRT        ;DONE A WHOLE LINE ?
	INY
	BCC MOVL10      ;NO
	JSR PAGRES      ;RESTORE RAM PAGE
	RTS
.SKIP 3
; ****** SCROLL DOWN ******
;
SCRDWN
	LDX LSXP
	BMI SCD30       ;SKIP IF NEW LINE FLAG ALREADY SET
	CPX TBLX
	BCC SCD30       ;SKIP IF OLD LINE IS BELOW SCROLL AREA
	INC LSXP        ;ELSE INC START LINE NUMBER
SCD30
	LDX SCBOT       ;SCROLL DOWN, START BOTTOM
SCD10
	JSR SCRSET      ;SET PNT TO LINE
	LDY SCLF
	CPX TBLX        ;TEST IF AT DESTINATION LINE
	BEQ SCD20       ;DONE IF YES
	DEX             ;POINT TO PREVIOUS LINE AS SOURCE
	JSR GETBT1
	INX
	JSR PUTBT1      ;MOVE CONTINUATION BYTE
	DEX
	JSR MOVLIN      ;MOVE ONE LINE
	BCS SCD10       ;ALWAYS
SCD20
	JSR CLRLN       ;SET LINE TO BLANKS
	JSR SETBIT      ;MARK AS CONTINUATION LINE
	RTS
.SKIP 3
; ****** SCROLL UP ******
;
SCRUP
	LDX SCTOP
SCRU00
	INX
	JSR GETBT1      ;FIND FIRST NON-CONTINUED LINE
	BCC SCRU15
	CPX SCBOT       ;IS ENTIRE SCREEN 1 LINE?
	BCC SCRU00      ;DO NORMAL SCROLL IF NOT
	LDX SCTOP
	INX
	JSR CLRBIT      ;CLEAR TO ONLY SCROLL 1 LINE
SCRU15
	DEC TBLX
	BIT LSXP
	BMI SCRU20      ;NO CHANGE IF ALREADY NEW LINE
	DEC LSXP        ;MOVE INPUT UP ONE
SCRU20
	LDX SCTOP
	CPX SEDT2
	BCS SCRU30
	DEC SEDT2       ;IN CASE DOING INSERT
SCRU30
	JSR SCR10       ;SCROLL
	LDX SCTOP
	JSR GETBT1
	PHP
	JSR CLRBIT      ;MAKE SURE TOP LINE IS NOT CONTINUATION
	PLP
	BCC SCRU10      ;DONE IF TOP LINE OFF
	BIT LOGSCR      ;LOGICAL SCROLL ?
	BMI SCRU15      ;YES - KEEP SCROLLING
SCRU10	RTS
;
;
SCR10
	JSR SCRSET      ;POINT TO START OF LINE
	LDY SCLF
	CPX SCBOT       ;AT LAST LINE ?
	BCS SCR40       ;YES
	INX             ;POINT TO NEXT LINE
	JSR GETBT1
	DEX
	JSR PUTBT1      ;MOVE CONTINUATION BYTE
	INX
	JSR MOVLIN      ;MOVE ONE LINE
	BCS SCR10
;
SCR40
	JSR CLRLN       ;MAKE LAST LINE BLANK
	LDX #$FF
	LDY #$FE        ;ALLOW ONLY OUTPUT LINE 0
	JSR GETLIN      ;GET INPUT
	AND #$20        ;CHECK IF INTERRUPT I5 = CONTROL
	BNE SCR80       ;IF NOT SKIP AHEAD - NOT SLOW SCROLL
SCR60
	NOP             ;YES - WASTE TIME
	NOP
	DEX
	BNE SCR60
	DEY
	BNE SCR60
SCR70
	STY NDX
SCR75
	LDX #$7F
	STX TPI2+PA     ;ALLOW ONLY OUTPUT LINE 15
	LDX #$FF        ;FOR STOP KEY DETECTION
	STX TPI2+PB
	RTS
;
SCR80
	LDX #$F7        ;ALLOW ONLY OUTPUT LINE 11
	LDY #$FF
	JSR GETLIN      ;GET INPUT LINES KEY
	AND #$10        ;CHECK FOR THE COMMODORE KEY
	BNE SCR75       ;EXIT IF NOT - NO STOP SCROLL
SCR90
	JSR GETLIN      ;GET INPUT LINES
	AND #$10        ;CHECK FOR THE COMMODORE KEY
	BEQ SCR90       ;WAIT UNTIL COM.KEY NOT DEPRESSED
SCR95
	LDY #0
	LDX #0          ;ALLOW ALL OUTPUT LINES
	JSR GETLIN      ;GET INPUTS
	AND #$3F        ;CHECK FOR ANY INPUT
	EOR #$3F
	BEQ SCR95       ;WAIT
	BNE SCR70       ;ALWAYS
.SKI 3
GETLIN
	SEI
	STX TPI2+PA     ;SET PORT-A OUTPUT
	STY TPI2+PB     ;SET PORT-B OUTPUTS
	JSR GETKEY      ;GET PORT-C INPUTS
	CLI
	RTS
.SKI  5
;RING THE BELL, IF ENABLED
BELL
     LDA BELLMD
     BNE BELLGO
     LDA #$0F
     STA SIDREG+24 ;TURN UP VOLUME
     LDY #00
     STY SIDREG+5 ;ATTACK=0-DECAY=9
     LDA #10
     STA SIDREG+6 ;SUSTAIN=0-RELEASE=0
     LDA #48
     STA SIDREG+1 ;VOICE 1 FREQ.
     LDA #96
     STA SIDREG+15 ;VOICE 3 FREQ.
     LDX #$15
     STX SIDREG+4
BELL10
     NOP
     NOP ;WAIT TO REACH SUSTAIN LEVEL
     INY
     BNE BELL10
     DEX
     STX SIDREG+4 ;GATE OFF
BELLGO
     RTS
.END
