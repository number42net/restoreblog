.PAG 'BVERBS2'
;   PROCESS PRINT# VERB
PRINTN	JSR CMD         ;DOCMD
	JMP IODONE      ;RELEASE CHANNEL
;
;
;   PROCESS CMD VERB
CMD	JSR GETBYT
	BEQ CMND2       ;IF NO MORE
	JSR CHKCOM      ;COMMA AFTER CHANNEL#
CMND2	PHP             ;SAVE STATUS
	PHA
	JSR CHKOUT      ;CHECK AND OPEN OUTPUT CHN
	STA CHANNL      ;SET CHN RETURNED FROM CHKOUT
	PLA
	PLP             ;GET STATUS BACK
	JMP PRINT       ;PROCESS RESET OF PRINT STM
;
STRDON	JSR STRPRT
NEWCHR	JSR CHRGOT      ;REGET LAST CHAR
;
;   PROCESS PRINT VERB
PRINT	BEQ OCRLF       ;TERMINATOR SO TYPE CR/LF
	.IFN CC2+CC3+CC4 <
	CMP #TKUSIN
	BNE PRINTC
	JMP USING       ;IF USING
>
;
;   HERE AFTER SEEING TAB(X) OR , OR ;
;   IN WHICH ASE A TERMIATOR DOES NOT
;  MEAN TYPE A CR/LF BUT JUST RTS.
PRINTC	BEQ OCRLFX
	CMP #TKTAB
	BEQ TABER       ;IF TAB FUNCTION
	CMP #TKSPC
	CLC
	BEQ TABER       ;IF SPACE
	CMP #',
	BEQ COMPRT      ;IF COMMA
	CMP #';
	BEQ NOTABR      ;IF SEMICOLON
	JSR FRMEVL      ;EVALUATE THE FORMULA
	BIT VALTYP
	BMI STRDON      ;IF STRING
	JSR OUTFAC
	JSR OSPC        ;OUTPUT A SPACE
	BNE NEWCHR      ;ALWAYS GOES
.PAG
;   ENTRY TO PROCESS CARRIAGE RETURN AND
;   OPTIONAL LINE FEED
OCRLF	LDA #CR
	JSR OCHR
	LDA CHANNL
	BPL CRFIN       ;CR ONLY
	LDA #LF         ;LINE FEED
	JSR OCHR
CRFIN	EOR #255
OCRLFX	RTS
;
COMPRT
	SEC             ;SET FLAG TO READ CURSOR POSITION
	JSR PLOT        ;GET CURSOR POSITION
	TYA
	SEC
MORCO1	SBC #CLMWID
	BCS MORCO1
	EOR #255
	ADC #1
	BNE ASPAC       ;ALWAYS
;
TABER	PHP             ;SPC OR TAB FUNCTION
	SEC
	JSR PLOT
	STY TRMPOS
	JSR GTBYTC
	CMP #')
	BNE SNERR2
	PLP
	BCC XSPAC
	TXA
	SBC TRMPOS
	BCC NOTABR
ASPAC	TAX
XSPAC	INX
XSPAC2	DEX
	BEQ NOTABR      ;IF SPACING COMPLETE
	JSR OSPC
	BNE XSPAC2
;
NOTABR	JSR CHRGET
	JMP PRINTC
;
SNERR2	JMP SNERR
.PAG
;GET COMMAND
;
;GET FROM KEYBOARD OR GET# FROM CHANNEL.
;THE VALUE OF AN ASCII 0 FOR A STRING VALUE IS
;THE NULL STRING.  THE VALUE OF AN ASCII 0 FOR
;A NUMERIC VALUE IS ALSO 0.  GET IS NOT ALLOWED
;IN DIRECT MODE.
;
GET	JSR ERRDIR      ;NOT ALLOWED IN DIRECT MODE
	JSR CHRGOT      ;REGET FIRST CHAR
	CMP #'#         ;WAS IT A GET# ?
	BNE GET010      ;NO...GET FROM KEYBOARD
	JSR GTBYTC      ;VALUE FOR CHANNEL#...RETURNED IN .X
	JSR CHKCOM      ;MUST BE COMMA BEFORE VARIABLE LIST
	JSR CHKIN       ;OPEN CHANNEL FOR INPUT
	STA CHANNL      ;NEW ACTIVE CHANNEL
;
;THIS ROUTINE PUTS A ZERO AS THE 2ND CHARACTER
;IN THE BUFFER AND POINTS (X,Y) AT IT.
;THIS FORCES A CALL TO GETIN BY INLOOP THE
;FIRST TIME AND ALSO ACTS AS A TERMINATOR.
;
GET010	LDA #TXTBNK     ;BUFFPT POINTS TO BUFFER
	LDY BUFFPT+1    ;BUFFPT POINTS TO BUFFER
	LDX BUFFPT
	INX             ;INCREMENT TO POINT TO 2ND ELEMENT
	BNE GET020
	INY
GET020	STX INDEX1      ;USE THIS AS INDEX
	STY INDEX1+1
	STA INDEX1+2
	LDY #0
	TYA             ;0 IN .A
	STA (INDEX1)Y   ;TO MAKE BUFFER TERMINATOR
	LDY INDEX1+1    ;PASS POINTER IN (.X,.Y)
	LDA #64         ;INPFLG WILL BE GET
	JSR INPCO1      ;GET AND FILL VARIABLE LIST...
	LDX CHANNL      ;GET FROM KEYBOARD?
	BNE IORELE      ;NO...CLOSE CHANNEL
	RTS             ;YES...DONE
.PAG
INPUTN	JSR GETBYT      ;MUST HAVE CHANNEL #
	JSR CHKCOM      ;COMMA AFTER CHANNEL #
	JSR CHKIN       ;OPEN CHN IN
	STA CHANNL
	JSR NOTQTI
;
;   CLOSE CURRENT WORKING CHANNEL
;
IODONE	LDA CHANNL
IORELE	JSR CLRCH
	LDX #0
	STX CHANNL
	RTS
.PAG
INPUT	CMP #'"         ;PROMPT STRING?
	BNE NOTQTI      ;NO...
	JSR STRTXT      ;YES...PRINT IT OUT
	LDA #';
	JSR SYNCHR      ;SEMI-C AS DELIMETER
	JSR STRPRT
NOTQTI	JSR ERRDIR
;
GETAGN	JSR QINLIN
	LDA CHANNL
	BEQ BUFFUL
	JSR READST      ;GET I/O STATUS BYTE
	AND #3          ;***STOP FOR TIMEOUTS***
	BEQ BUFFUL      ;GOOD INPUT
	JSR IODONE      ;BAD INPUT
	JMP DATA        ;SKIP REST OF THIS STATEMENT
;
BUFFUL	LDY #0
	LDA (INDEX1)Y   ;ANYTHING IN BUFFER?
	BEQ BUFFU2
;
;INPUT READY TO PROCESS
;POINT AT COMMA BEFORE BUFFER
;
BUFFU1	LDY BUFFPT+1
	LDX BUFFPT
	BNE *+3
	DEY
	DEX
	JMP INPCON
;
;BUFFER WAS EMPTY
;IF FROM DEVICE, TRY AGAIN IF NOT EOI
;OTHERWISE DEFAULT ALL VARIABLES
;
BUFFU2	LDA CHANNL
	BNE *+5
	JMP DATA        ;FROM KEYBOARD, SKIP REST OF STMT
	JSR READST      ;FROM DEVICE, CHECK FOR EOI
	AND #$40
	BEQ GETAGN      ;NO EOI, WAS ONLY A CR
	BNE BUFFU1      ;EOI, FILL WITH NULL VALS
;
QINLIN	LDA CHANNL      ;KEYBOARD/CRT?
	BNE GINLIN      ;NO...
	JSR OUTQST      ;YES..PROMPT
	JSR OSPC
GINLIN	JMP INLIN
.PAG
;   FIND DATA
;   SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA
;   TO SKIP OVER STATMENTS.  THE START WORD OF EACH
;   STATEMENT IS COMPARED WITH 'DATATK'. EACH NEW LINE
;   NUMBER IS STORED IN 'DATLIN' SO THAT IF AN ERROR
;   OCCURS WHILE READING DATA THE ERROR MSG CAN GIVE
;   THE LINE # OF THE ILL-FORMATTED DATA.
DATLOP
	JSR DATAN
	INY
	TAX
	BNE NOWLIN
	LDA TXTPTR+2
	STA I6509
	LDA (TXTPTR)Y   ;LOOK FOR NULL LINKS
	BNE DTLP0
	INY
	LDA (TXTPTR)Y
	BNE DTLP1       ;IF NO ERROR
	LDX #ERROD
	JMP ERROR
;
DTLP0
	INY
DTLP1
	INY             ;POINT STORED STMT TO LINE NO.
	LDA (TXTPTR)Y
	STA DATLIN
	INY
	LDA (TXTPTR)Y
	INY
	STA DATLIN+1
NOWLIN
	JSR MAPTXT
	JSR ADDON
	JSR CHRGOT
	TAX
	CPX #TKDATA
	BNE DATLOP
	JMP DATBK1
;
DATLPX
	JMP DATLOP
.PAG
;   IN THE PROCESSING OF DATA AND READ STATEMENTS
;   ONE -> POINTS TO THE DATA (IE, THE #S BEING FETCHED)
;   AND ANOTHER POINTS TO THE LIST OF VARIABLES.
;
;   THE -> INTO THE DATA ALWAYS STARTS POINTING TO A
;   TERMINATOR -- A ,  OR EOL
;
;   AT THIS POINT TXTPTR POINTS TO LISTO OF VARIABLES AND
;   (Y,X) POINTS TO DATA OR INPUT LINE.
;
;   NOTE, SINCE BOTH DATA STATEMENTS AND THE INPUT BUFFER
;   ARE IN THE TEXT BANK, THE BANK FOR INDIRECTION AND
;   THE TEXT POINTER, TXTPTR, IS ALWAYS TEXT.
;
READ	LDX DATPTR
	LDY DATPTR+1
	LDA #$98
	.BYTE $2C       ;EAT THE NEXT TWO BYTES
INPCON	LDA #0
INPCO1	STA INPFLG
	STX INPPTR
	STY INPPTR+1
INLOOP	JSR PTRGET
	STA FORPNT
	STY FORPNT+1
	STX FORPNT+2
	LDA TXTPTR
	LDY TXTPTR+1
	STA VARTXT
	STY VARTXT+1
	LDX INPPTR
	LDY INPPTR+1
	STX TXTPTR
	STY TXTPTR+1
	JSR CHRGOT
	BNE DATBK1
	BIT INPFLG
	BVC QDATA
	JSR GETIN
	LDY BUFFPT+1
	LDX BUFFPT
	BNE INC05
	DEY
INC05	DEX
	STX INDEX1
	STY INDEX1+1
	LDY #1
	STA (INDEX1)Y
	LDY INDEX1+1
	JMP DATBK
QDATA	BMI DATLPX
	LDA CHANNL
	BNE GETNTH
	JSR OUTQST
GETNTH	JSR QINLIN
	TAX
DATBK	STX TXTPTR
	STY TXTPTR+1
DATBK1	JSR CHRGET
	BIT VALTYP
	BPL NUMINS
	BIT INPFLG
	BVC SETQUT
	INX
	STX TXTPTR
	LDA #0
	STA CHARAC
	BEQ RESETC
SETQUT	STA CHARAC
	CMP #'"
	BEQ NOWGET
	LDA #':
	STA CHARAC
	LDA #',
RESETC	CLC
NOWGET	STA ENDCHR
	JSR SAV30
	JSR STRLT2
	JSR ST2TXT
	JSR INPCOM
	JMP STRDN2
SAV30	LDA TXTPTR
	LDY TXTPTR+1
	ADC #0
	BCC NOWGE1
	INY
NOWGE1	LDX TXTPTR+2
	RTS
;
NUMINS	JSR FIN
	LDA INTFLG
	JSR QINTGR
STRDN2	JSR CHRGOT
	BEQ TRMOK
	CMP #',
	BNE TRMNOK
;
TRMOK	LDA TXTPTR
	LDY TXTPTR+1
	STA INPPTR
	STY INPPTR+1
	LDA VARTXT
	LDY VARTXT+1
	STA TXTPTR
	STY TXTPTR+1
	JSR CHRGOT
	BEQ ENDVAR
	JSR CHKCOM
	JMP INLOOP
;
;   HERE WHEN THE DATA THAT WAS TYPED IN OR IN 'DATA'
;   STATEMENTS IS IMPROPERLY FORMATTED.  FOR 'INPUT'
;   WE START AGAIN.
;   FOR 'READ' WE GIVE A SYNTAX ERROR AT THE DATA LINE.
TRMNOK	LDA INPFLG
	BEQ TRMNO1      ;IF INPUT TRY AGAIN
	BPL SNERR6      ;GET STMT, ISSUE SYNTAX ERR
;;BMI GETDTL
;;LDY #255 ;MAKE IT LOOK DIRECT
;;BNE STCURL ;ALWAYS GOES
GETDTL	LDA DATLIN      ;GET DATA LINE NUMBER
	LDY DATLIN+1
STCURL	STA CURLIN      ;MAKE IT CURRENT LINE
	STY CURLIN+1
SNERR6	JMP SNERR
;
TRMNO1	LDA CHANNL      ;IF NOT TERMINAL, GIVE BAD DATA
	BEQ DOAGIN
	LDX #ERRBD
	JMP ERROR
;
DOAGIN	LDX #TRYAGN
	JSR MSG         ;PRINT '?REDO FROM START'
	LDA OLDTXT      ;-> AT START OF THIS CURRENT LINE
	LDY OLDTXT+1
	STA TXTPTR
	STY TXTPTR+1
	RTS             ;GO TO NEWSTT
.SKI 4
ENDVAR	LDA INPPTR
	LDY INPPTR+1
	LDX INPFLG
	BPL VARY0
	STA DATPTR
	STY DATPTR+1
	RTS
;
VARY0
	LDY #0
	LDA (INPPTR)Y
	BEQ INPRTS
	LDA CHANNL
	BNE INPRTS
	LDX #EXIGNT
	JMP MSG
;
INPRTS	RTS
.PAG
;
;  SYS COMMAND
;
CSYS	JSR GETPIN      ;GET POSITIVE INTEGER
	LDA #>CSYSRZ    ;PUSH RETURN ADDRESS
	PHA
	LDA #<CSYSRZ
	PHA
	JMP (POKER)
CSYSRZ	=*-1
	RTS
.SKI 4
DIM3	JSR CHKCOM
DIM	TAX
	JSR PTRGT1
	JSR CHRGOT
	BNE DIM3
	RTS
.SKI 4
DEFN	JSR GETFNM
	JSR ERRDIR
	JSR CHKOPN
	LDA #128
	STA SUBFLG
	JSR PTRGET
	JSR CHKNUM
	JSR CHKCLS
	LDA #TKEQUL     ;MUST HAVE EQUAL TOKEN
	JSR SYNCHR
	LDA VARPNT+2
	PHA
	LDA VARPNT+1
	PHA
	LDA VARPNT
	PHA
	LDA TXTPTR+1
	PHA
	LDA TXTPTR
	PHA
	JSR DATA
	JMP DEFFIN
.SKI 4
POKE	JSR GETNUM
	TXA
	JSR SAV32
	STA (POKER)Y
	STX I6509
	RTS
.SKI 4
FNWAIT	JSR GETNUM
	STX ANDMSK
	LDX #0
	JSR CHRGOT
	BEQ STORDO
	JSR COMBYT
STORDO	STX EORMSK
	JSR SAV32
WAITER	LDA (POKER)Y
	EOR EORMSK
	AND ANDMSK
	BEQ WAITER
	STX I6509
	RTS
SAV32	LDX I6509
	LDY DFBANK
	STY I6509
	LDY #0
	RTS
.SKI 4
; KEY PROCESSOR:   KEY [ KEY NUMBER , STRING ]
;
FKEY
	BNE KEY20
	LDY #0          ;NO PARAMS => LIST ALL KEYS
	BEQ KEYGO       ;ALWAYS
KEY20
	JSR GETBYT      ;.X := POSITIVE BYTE INTEGER
	TXA
	BNE KEY40       ;MUST BE NON-ZERO
FCERR3	JMP FCERR
KEY40	CMP #21
	BCS FCERR3      ;MUST BE <= 20
	PHA             ;SAVE KEY NUMBER
	JSR CHKCOM
	JSR SAV13
	STA HIGHDS      ;SET UP STRING DESCRIPTOR
	LDA INDEX1
	LDX INDEX1+1
	LDY INDEX1+2
	STA HIGHDS+1
	STX HIGHDS+2
	STY HIGHDS+3
	PLA
	TAY             ;.Y := KEY NUMBER
	LDA #<HIGHDS    ;NOTE HIGHTR MUST FOLLOW HIGHDS
KEYGO
	JMP PGMKEY      ;DO IT!
SAV13	JSR FRMEVL
	JMP FRESTR
.PAG
CVERF	;PROCESS VERIFY VERB
	LDA #ERRVR      ;SET MESSAGE TABLE POINTER
	PHA
	LDA #$80        ;SET VERIFY FLAG
	JSR LDVER       ;LOAD/VERIFY ROUTINE
	BEQ CVF1        ;IF DIRECT MODE
	PLA
	RTS
.SKI 4
;   PROCESS LOAD VERB
CLOAD
	LDA #0          ;SET LOAD FLAG
	JSR LDVER       ;LOAD/VERIFY ROUTINE
;
LOADCK	;ENTRY FROM DLOAD
	BEQ CLF1        ;IF DIRECT MODE
	JSR LNKPRG      ;RELINK
	JSR STXTPT      ;POINT TXTPTR TO NULL BYTE
	JMP FLOAD       ;SET STACK POINTER
;
CLF1
	LDA TTTEMP      ;GET BANK OF END OF LOAD
	CMP #TXTBNK
	BNE CLD4        ;BAD, OUT OF TEXT MEMORY
	.IFN CC1 <
	STX VARTAB      ;SAVE NEW TEXT END(64K)
	STY VARTAB+1
>
	.IFE CC1 <
	STX TXTEND      ;SAVE NEW TEXT END(128,192,256K)
	STY TXTEND+1
>
	LDA #ERRLD      ;SET MESSAGE TABLE POINTER
	PHA
;
CVF1
	JSR READST      ;READ STATUS OF LOAD/VERIFY
	AND #$10
	BNE CLD2        ;IF ERROR
	PLA
	LDA #MSRDY
	PHA
;
CLD2
	PLA
	TAX
CLD3
	JSR MSG         ;OUTPUT MESSAGE
	JMP FINI        ;RELINK, SET END OF TEXT AND GOTO MAIN LOOP
;
CLD4
	.IFN CC1 <
	LDX ERROM       ;64K
>
	.IFE CC1 <
	LDX ERROT       ;EXCEPT 64K
>
	BNE CLD3        ;ALWAYS
.SKI 4
;   ENTRY FROM DLOAD
LOADNP
	PHA             ;A = 0
	BEQ LVR1        ;ALWAYS
;
;   ENTRY A = 0 IF NO VERIFY, <>0 IF VERIFY
LDVER
	PHA             ;SAVE LOAD/VERIFY FLAG
	JSR PLSV        ;VERIFY ENTRY
;
LVR1
	JSR KSTOP
	BEQ LVR1        ;DEBOUNCE
;
	PLA             ;RESTORE FLAG
	ORA #TXTBNK     ;PACK IN BANK#
	LDX #$03        ;LOAD INTO TEXT TABLE
	LDY #$00
	JSR LOAD        ;REQUEST LOAD FROM KERNAL
	BCS LDSVER      ;IF LOAD/VERIFY ERROR
	STA TTTEMP      ;SAVE BANK OF END OF LOAD
      JMP TDM         ;GET DIRECT MODE
.SKI 4
;   PROCESS BASIC SAVE COMMAND.
;
CSAVE
	JSR PLSV
;
SAVENP
	LDX TXTTAB      ;HIGHDS IS START VECTOR
	LDY TXTTAB+1
	LDA #TXTBNK
	STX HIGHDS
	STY HIGHDS+1
	STA HIGHDS+2
	.IFN CC1 <
	LDX VARTAB      ; 64K
	LDY VARTAB+1    ;HIGHTR IS END VECTOR
>
	.IFE CC1 <
	LDX TXTEND      ; EXCEPT 64K
	LDY TXTEND+1    ;HIGHTR IS END VECTOR
>
SAVENB
	STX HIGHTR
	STY HIGHTR+1
	STA HIGHTR+2
	LDX #<HIGHDS
	LDY #<HIGHTR
	JSR SAVE
	BCS LDSVER      ;LOAD/SAVE ERROR
	RTS
.SKI 4
LDSVER
	ASL A           ;DOUBLE ERROR NUMBER
	TAX             ;TRANSFER TO X
	JMP ERROR       ;PROCESS ERROR
.SKI 4
;   PROCESS OPEN VERB
COPEN
	LDX #00         ;SET DEFAULT PARAMETERS
	STX PARSTS      ;CLEAR STATUS
	STX DOSF1L      ;SET LENGTH TO ZERO
	STX DOSSA       ;SET SECONDARY ADDRESS TO ZERO
	INX
	STX DOSFA       ;SET DEVICE NUMBER TO ONE
	JSR PLSV32
	JSR GETBYT
	STX DOSLA       ;SET LOGICAL FILE NUMBER
	JSR COPS        ;GET NEXT NUMBER IF ONE
	STX DOSFA       ;SAVE DEVICE NUMBER
	LDY #0
	CPX #3
	BCC COP1        ;IF NOT IEEE
	DEY
COP1
	STY DOSSA       ;SET DEFAULT SECONDARY ADDRESS
	JSR COPS        ;GET NEXT NUMBER IF ONE
	STX DOSSA       ;SET SECONDARY ADDRESS
	JSR CHRGOT
	BEQ COPX        ;IF END OF STATEMENT
	JSR PLSV30
	JSR SAV13
	STA DOSF1L      ;SAVE LENGTH
	LDA INDEX1      ;SAVE STRING ADDRESS
	LDY INDEX1+1
	LDX INDEX1+2
	STA DOSF1A
	STY DOSF1A+1
	STX DOSF1B
;
COPX
	JSR PLSVX       ;SET FILE INFO
	JMP OPEN
;
COPS
	JSR CHRGOT
	BNE COPG
	PLA             ;IF END OF STATEMENT, SCRAP RETURN...
	PLA             ;...AND GO OFF TO OPEN IT
	JMP COPX
COPG	JSR PLSV30      ;ELSE GET NEXT DEVICE PARAM AND CONTINUE
	JMP GETBYT
.SKI 4
;   PROCESS CLOSE VERB
CCLOS
	JSR PLSV32
	JSR GETBYT
	TXA
	JMP CLOSE
.END
