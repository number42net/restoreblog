.PAG 'MONITOR 05/02/83'
;************************************************
;*                                              *
;* KERNAL MONITOR                               *
;*                                              *
;* ENTRY VIA CALL (JMP) OR BREAKPOINT (BRK)     *
;* ---FUNCTIONS---                              *
;* <:>      ALTER MEMORY                        *
;* <;>      ALTER REGISTERS                     *
;* <R>      DISPLAY REGISTERS                   *
;* <M>      DISPLAY MEMORY                      *
;* <G>      START EXECUTION OF CODE             *
;* <L>      LOAD MEMORY                         *
;* <S>      SAVE MEMORY                         *
;* <V>      VIEW SEGMENT                        *
;* <@>      DISK COMMAND                        *
;* <X>      WARM START BASIC                    *
;* <U>      SET DEFAULT DISK UNIT               *
;* <OTHER>  LOAD AND EXECUTE FROM DISK          *
;*                                              *
;* FOR SYNTAX & SEMANTICS SEE CBM KERNAL MANUAL *
;* COPYRIGHT (C) 1981 BY CBM                    *
;************************************************
.PAG 'MONITOR'
; RESET ENTRY
	* = $EE00
;
;*****WARM START ENTRY*******
;
MONON	JSR IOINIT      ;GET I/O
	JSR RESTOR      ;VECTORS
	JSR CINT        ;SCREEN EDITOR
;
;*****COLD START ENTRY******
;
MONOFF
	JSR CLRCH       ;CLEAR CHANNELS
	LDA #WINIT      ;WASTE TWO BYTES SO TIMC=60950
	LDX #<MONON     ;POINT RESET VECTORS AT MONITOR ON
	LDY #>MONON
	JSR VRESET
	CLI             ;RELEASE IRQ'S
;
;*****CALL ENTRY*****
;
TIMC	LDA #$40+$80
	STA MSGFLG      ;ERROR+MESSAGES ON
	LDA #MS34-MS1   ;CALL ENTRY
	STA TMPC
	BNE B3          ;BRANCH ALWAYS
;
;*****BREAK ENTRY*****
;
TIMB	JSR CLRCH       ;CLR CHANNELS
	LDA #MS36-MS1   ;BREAK ENTRY
	STA TMPC
	CLD 
;
;SAVE .Y,.X,.A,FLAGS, AND PC
;
	LDX #5
B1	PLA
	STA PCH,X
	DEX
	BPL B1
;
B3
	LDA I6509       ;SAVE INDIRECTION SEGMENT
	STA XI6509
	LDA CINV
	STA INVL        ;SAVE IRQ LOW
	LDA CINV+1
	STA INVH        ;SAVE IRQ HIGH
;
	TSX
	STX SP          ;SAVE ORIGINAL SP
	CLI             ;CLEAR INTS
	LDA #8          ;SET DISK DEFAULT TO 8
	STA DDISK
;
B5	LDY TMPC        ;MESSAGE CODE
	JSR SPMSG       ;PRINT BREAK/CALL
;
	LDA #'R         ;DISPLAY REGS ON ENTRY
	BNE S0          ;BRANCH ALWAYS
;
;*****ERROR ENTRY*****
;
ERROPR	JSR OUTQST
	PLA
	PLA
;
;*****COMMAND INTERPRETER ENTRY*****
;
STRTM1=*-1
	LDA #$40+$80
	STA MSGFLG      ;I/O MESSAGES TO SCREEN
	LDA #<BUF       ;PUT FILENAME AT BOTTOM OF BASIC BUFFER
	STA FNADR
	LDA #>BUF
	STA FNADR+1
	LDA #IROM
	STA FNADR+2
	JSR CRLF
;
ST1	JSR BASIN       ;READ COMMAND
	CMP #'.'
	BEQ ST1         ;SKIP PROMPT CHARACTERS
	CMP #$20
	BEQ ST1         ;SPAN BLANKS
	JMP (USRCMD)    ;USER INDIRECT FOR MONITOR
;
;COMMAND INTERPRETER
;
S0	LDX #0
	STX FNLEN
	TAY             ;SAVE CURRENT COMMAND
;
;PUT RETURN ADDRESS FOR COMMANDS ON STACK
;
	LDA #>STRTM1
	PHA
	LDA #<STRTM1
	PHA
;
	TYA             ;CURRENT COMMAND IN .A
;
S1	CMP CMDS,X      ;IS IT THIS ONE?
	BNE S2          ;NOTIT
;
	STA SAVX        ;SAVE CURRENT COMMAND
;
;INDIRECT JMP FROM TABLE
;
	LDA CMDS+1,X
	STA TMP0
	LDA CMDS+2,X
	STA TMP0+1
	JMP (TMP0)
;
;EACH TABLE ENTRY IS 3 LONG---SKIP TO NEXT
;
S2	INX
	INX
	INX
	CPX #CMDEND-CMDS
	BCC S1          ;LOOP FOR ALL COMMANDS
;
;COMMAND NOT IN TABLE...LOOK ON DISK.
;COMMAND NAME CAN BE ANY LENGTH AND
;HAVE PARAMETERS.
;
	LDX #0          ;LENGTH TO ZERO
S3	CMP #$D         ;END OF NAME?
	BEQ S4          ;YES...
	CMP #$20        ;BLANK?
	BEQ S4          ;YES
	STA BUF,X
	JSR BASIN       ;GET NEXT
	INX             ;COUNT CHAR
	BNE S3          ;AND CONTINUE
;
S4	STA TMPC
	TXA             ;COUNT
	BEQ S6          ;IS ZERO
;
	STA FNLEN
	LDA #$40
	STA MSGFLG      ;MESSAGES OFF
	LDA DDISK       ;
	STA FA          ;WILL USE DEFAULT DISK
	LDA #IROM       ;COMMANDS ONLY LOAD TO ROM SEGMENT !!!***
	STA I6509       ;TURN INDIRECT TO ROM SEGMENT
	LDX #$FF
	LDY #$FF
	JSR LOAD        ;TRY TO LOAD COMMAND
	BCS S6          ;BAD LOAD...
;
	LDA TMPC        ;PASS LAST CHARACTER
	JMP (STAL)      ;GO DO IT
;
S6	RTS
.SKI 3
CMDS	.BYT ':'        ;ALTER MEMORY
	.WOR ALTM
	.BYT ';' ;ALTER REGISTERS
	.WOR ALTR
	.BYT 'R'        ;DISPLAY REGISTERS
	.WOR DSPLYR
	.BYT 'M'        ;DISPLAY MEMORY
	.WOR DSPLYM
	.BYT 'G'        ;START EXECUTION
	.WOR GO
	.BYT 'L'        ;LOAD MEMORY
	.WOR LD
	.BYT 'S'        ;SAVE MEMORY
	.WOR LD
	.BYT 'V'        ;VIEW SEGMENT
	.WOR VIEW
	.BYT '@'        ;DISK COMMAND (ALTERNATE)
	.WOR DISK
	.BYT 'Z'        ;TRANSFER TO 2ND MICROPROCESSOR
	.WOR IPCGOV     ;IPCGO VECTOR
	.BYT 'X'        ;WARM START BASIC
	.WOR XEIT
	.BYT 'U'        ;DEFAULT DISK UNIT SET
	.WOR UNITD
CMDEND
.SKI 5
XEIT	PLA             ;REMOVE COMMAND RETURN FROM STACK
	PLA
	SEI             ;DISABLE INTERRUPTS...ALL WARM START CODE EXPECTS
	JMP (EVECT)     ;GO WARMSTART LANGUAGE
.SKI 5
PUTP	LDA TMP0        ;MOVE TMP0 TO PCH,PCL
	STA PCL
	LDA TMP0+1
	STA PCH
	RTS
.SKI 5
SETR	LDA #<FLGS      ;SET TO ACCESS REGS
	STA TMP0
	LDA #>FLGS
	STA TMP0+1
	LDA #IROM       ;POINT INDIRECT AT ROMS
	STA I6509
	LDA #5
	RTS
.SKI 5
;PRINTS '.:' OR '.;' BEFORE DATA TO PERMIT
;ALTER AFTER 'M' OR 'R' COMMAND
;
ALTRIT	PHA             ;PRESERVE ALTER CHARACTER
	JSR CRLF
	PLA
	JSR BSOUT
.SKI 3
SPACE	LDA #$20        ;OUTPUT A SPACE
	.BYT $2C        ;SKIP TWO BYTES
OUTQST	LDA #'?         ;OUTPUT QUESTION
	JMP BSOUT       ;GO PRINT BYTES
CRLF	LDA #$D         ;DO CARRIAGE RETURN
	JSR BSOUT
	LDA #'.'        ;MONITOR PROMPT
	JMP BSOUT
.SKI 5
;DATA FOR REGISTER DISPLAY HEADING
;
REGK	.BYT CR,$20,$20 ;3 SPACES
	.BYT ' PC ',' IRQ ',' SR AC XR YR SP'
.SKI 5
;DISPLAY REGISTER FUNCTION
;
DSPLYR	LDX #0
D2	LDA REGK,X
	JSR BSOUT       ;PRINT HEADING
	INX
	CPX #DSPLYR-REGK ;MAX LENGTH
	BNE D2
	LDA #';
	JSR ALTRIT      ;ALLOW ALTER AFTER DISPLAY
	LDX PCH
	LDY PCL
	JSR WROA        ;PRINT PROGRAM COUNTER
	JSR SPACE
	LDX INVH
	LDY INVL
	JSR WROA        ;PRINT IRQ VECTOR
	JSR SETR        ;SET TO PRINT .P,.A,.X,.Y,.S
;
;DISPLAY MEMORY SUBROUTINE
;
DM	STA TMPC        ;BYTE COUNT
	LDY #0          ;INDIRECT INDEX
	STY FNLEN       ;FNLEN IS ZERO-PAGE CROSSING FLAG...
DM1	JSR SPACE       ;SPACE TWEEN BYTES
	LDA (TMP0)Y
	JSR WROB        ;WRITE BYTE OF MEMORY
;
;INCREMENT INDIRECT
;
	INC TMP0
	BNE DM2
	INC TMP0+1
	BNE DM2         ;NO ZERO PAGE CROSSING
	DEC FNLEN       ;FNLEN<>0 IS FLAG
;
DM2	DEC TMPC        ;COUNT BYTES
	BNE DM1         ;UNTIL ZERO
	RTS
.SKI 5
;DISPLAY MEMORY FUNCTION
;
DSPLYM	JSR RDOAE       ;READ START ADR...ERR IF NO SA
	JSR T2T2        ;SA TO TMP2
;
;ALLOW USER TO TYPE JUST ONE ADDRESS
;
	JSR RDOA        ;READ END ADR
	BCC DSP123      ;GOOD...NO DEFAULT
;
	LDA TMP2
	STA TMP0        ;DEFAULT LOW BYTE
	LDA TMP2+1
	STA TMP0+1      ;DEFAULT HI BYTE
;
DSP123	JSR T2T2        ;SA TO TMP0, EA TO TMP2
DSP1	JSR STOP        ;STOP KEY?
	BEQ BEQS1       ;YES...BREAK LIST
;
	LDA #':
	JSR ALTRIT      ;ALLOW ALTER
	LDX TMP0+1
	LDY TMP0
	JSR WROA        ;WRITE START ADDRESS
	.IFN SYSTEM <
	LDA #8          ;COUNT OF BYTES
>
	.IFE SYSTEM <
	LDA #16         ;COUNT OF BYTES CBMII
>
	JSR DM          ;DISPLAY BYTES
;
;CHECK FOR END OF DISPLAY
;
	LDA FNLEN       ;CHECK FOR ZERO-CROSSING
	BNE BEQS1       ;YUP....
	SEC
	LDA TMP2
	SBC TMP0
	LDA TMP2+1
	SBC TMP0+1
	BCS DSP1        ;END >= START
;
BEQS1	RTS             ;A.O.K. EXIT
;
.SKI 5
;ALTER REGISTER FUNCTION
;
ALTR	JSR RDOAE       ;READ NEW PC...NO ADDRESS=ERROR
;
	JSR PUTP        ;ALTER PC
;
	JSR RDOAE       ;READ NEW IRQ...NO ADDRESS=ERROR
;
	LDA TMP0
	STA INVL        ;ALTER IRQ VECTOR
	LDA TMP0+1
	STA INVH
;
	JSR SETR        ;SET TO ALTER R'S
	BNE A4          ;BRANCH ALWAYS
.SKI 2
;VIEW A SEGMENT (POINT INDIRECT)
;
VIEW	JSR RDOBE       ;GET A BYTE...IF NONE...ERROR
	CMP #16         ;RANGE 0-15
	BCS ERRL        ;TO LARGE NO MODULO
	STA I6509
	RTS
.SKI 2
;UNIT DEFAULT FOR DISK
;
UNITD	JSR RDOBE       ;GET A BYTE...IF NONE...ERROR
	CMP #32         ;RANGE 0-31
	BCS ERRL        ;TO LARGE NO MODULO
	STA DDISK
	RTS
.SKI 2
;ALTER MEMORY - READ ADR AND DATA
;
ALTM	JSR RDOAE       ;READ ALTER ADR...IF NONE...ERROR
;
	.IFN SYSTEM <
	LDA #8          ;ALLOW 8 BYTES CHANGE
>
	.IFE SYSTEM <
	LDA #16         ;ALLOW 16 BYTES CHANGE
>
;
;COMMON CODE FOR ':' AND ';'
;
A4	STA TMPC        ;NUMBER OF BYTES TO CHANGE
;
A5	JSR RDOB        ;READ BYTE
	BCS A9          ;NONE...END OF LINE
;
	LDY #0
	STA (TMP0)Y     ;STORE IT AWAY
;
;INCREMENT STORE ADDRESS
;
	INC TMP0
	BNE A6
	INC TMP0+1
;
A6	DEC TMPC        ;COUNT BYTE
	BNE A5          ;UNTIL ZERO
;
A9	RTS
.SKI 5
;START EXECUTION FUNCTION
;
GO	JSR RDOC        ;SEE IF DEFAULT
	BEQ G1          ;YES...PC IS ADDRESS
;
	JSR RDOAE       ;NO...GET NEW ADDR...NONE=ERROR
;
	JSR PUTP        ;MOVE ADDR TO P.C.
;
G1	LDX SP
	TXS             ;ORIG OR NEW SP VALUE TO SP
;
	SEI             ;PREVENT DISASTER
;
	LDA INVH
	STA CINV+1      ;SET UP IRQ VECTOR
	LDA INVL
	STA CINV
	LDA XI6509      ;AND INDIRECTION REGISTER
	STA I6509
;
;GET FLAGS,PCH,PCL,.A,.X,.Y
;
	LDX #0
G2	LDA PCH,X
	PHA             ;EVERYBODY ON STACK
	INX
	CPX #6
	BNE G2
;
;INTERRUPT RETURN SETS EVERYBODY UP
;FROM DATA ON STACK
;
	JMP PREND
.SKI 3
; RDOBE - READ A BYTE AND ERROR ON LINE END..WASTE STACK
;
RDOBE	JSR RDOB
	BCS ERRLPL
RDOXIT	RTS
;
; RDOAE - READ AN ADDRESS AND ERROR ON LINE END...WASTE STACK
;
RDOAE	JSR RDOA
	BCC RDOXIT
;
ERRLPL	PLA             ;ZAP STACK
	PLA
ERRL	JMP ERROPR      ;SYNTAX ERROR JUMP
.SKI 3
;LOAD RAM FUNCTION
;  *NOTE - LOAD/SAVE RESET INDIRECT TO ROM
;
LD	LDY #1
	STY FA          ;DEFAULT DEVICE #1
	DEY             ;.Y=0 TO COUNT NAME LENGTH
	LDA #$FF        ;DEFAULT NO MOVE LOAD
	STA TMP0
	STA TMP0+1
	LDA I6509       ;SAVE INDIRECT FOR SEG ADDRESS
	STA T6509
	LDA #IROM       ;INDIRECT TO ROM FOR FILENAME
	STA I6509
;
L1	JSR RDOC        ;DEFAULT?
	BEQ L5          ;YES...TRY LOAD
;
	CMP #' 
	BEQ L1          ;SPAN BLANKS
;
	CMP #'"         ;STRING NEXT?
L2	BNE ERRL        ;NO FILE NAME...
;
L3	JSR RDOC        ;GET CHARACTER OF NAME
	BEQ L5          ;END...ASSSUME LOAD
;
	CMP #'"         ;END OF STRING?
	BEQ L8          ;YES...COULD STILL BE 'L' OR 'S'
;
	STA (FNADR)Y    ;STORE NAME
	INC FNLEN
	INY
	CPY #16         ;MAX FILE NAME LENGTH
;
L4	BEQ ERRL        ;FILE NAME TOO LONG
	BNE L3          ;BRANCH ALWAYS
;
;SEE IF WE GOT A LOAD
;
L5	LDA SAVX        ;GET LAST COMMAND
	CMP #'L
	BNE L2          ;NO..NOT A LOAD..ERROR
;
	LDA T6509       ;GET SEGMENT TO LOAD TO
	AND #IROM       ;MASK OFF VERIFY BIT
	LDX TMP0
	LDY TMP0+1
	JMP LOAD        ;YES...DO LOAD
;
L8	JSR RDOC        ;MORE STUFF?
	BEQ L5          ;NO...DEFUALT LOAD
;
	CMP #',         ;DELEIMETER?
L9	BNE L2          ;NO...BAD SYNTAX
;
	JSR RDOBE       ;YES...GET NEXT PARM...ERROR IF NONE
;
	STA FA
;
	JSR RDOC        ;MORE PARMS?
	BEQ L5          ;NO...DEFAULT LOAD
;
	CMP #',         ;DELIMETER?
L12	BNE L9          ;NO...BAD SYNTAX
;
	JSR RDOBE       ;SEGMENT BYTE ?...MUST HAVE
	CMP #16         ;00-0F ALLOWED
	BCS L15         ;TOO BIG...
	STA T6509
	STA STAS        ;PREP SEGMENT
	JSR RDOAE       ;START ADDRESS?...MUST HAVE
;
;SET UP START SAVE ADDRESS
;
	LDA TMP0
	STA STAL
	LDA TMP0+1
	STA STAH
;
	JSR RDOC        ;DELIMETER?
	BEQ L5          ;CR, DO LOAD
	CMP #',
	BNE L15         ;NO DELIM
;
	JSR RDOBE       ;GET SEGMENT BYTE...MUST HAVE
	CMP #16         ;ALLOW ONLY 00-0F
	BCS L15         ;TOO BIG...
	STA EAS         ;PREP SEGMENT
	JSR RDOAE       ;TRY TO READ END ADDRESS...MUST HAVE
;
;SET UP END SAVE ADDRESS
;
	LDA TMP0
	STA EAL
	LDA TMP0+1
	STA EAH
;
L20	JSR BASIN
	CMP #$20
	BEQ L20         ;SPAN BLANKS
;
	CMP #CR
L14	BNE L12         ;MISSING CR AT END
	LDA SAVX        ;WAS COMMAND SAVE?
	CMP #'S
	BNE L14         ;NO...LOAD CAN'T HAVE PARMS
	LDX #STAL       ;GET PARAMS FOR SAVE
	LDY #EAL
	JMP SAVE
;
L15	JMP ERROPR
.SKI 5
;WRITE ADR FROM TMP0 STORES
;
WROA	TXA             ;HI-BYTE
	JSR WROB
	TYA             ;LOW-BYTE
.SKI 3
;WRITE BYTE --- A = BYTE
;UNPACK BYTE DATA INTO TWO ASCII
;CHARACTERS. A=BYTE; X,A=CHARS
WROB	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR ASCII       ;CONVERT TO ASCII
	TAX
	PLA
	AND #$0F
.SKI 3
;CONVERT NYBBLE IN A TO ASCII AND
;PRINT IT
;
ASCII	CLC
	ADC #$F6
	BCC ASC1
	ADC #$06
ASC1	ADC #$3A
	JMP BSOUT
.SKI 5
;EXCHANGE TEMPORARIES
;
T2T2	LDX #2
T2T21	LDA TMP0-1,X
	PHA
	LDA TMP2-1,X
	STA TMP0-1,X 
	PLA
	STA TMP2-1,X
	DEX
	BNE T2T21
	RTS
.SKI 5
;READ HEX ADR,RETURN HI IN TMP0,
;LO IN TMP0+1,AND CY=1
;IF SP CY=0
;
RDOA	JSR RDOB        ;READ 2-CHAR BYTE
	BCS RDOA2       ;SPACE
	STA TMP0+1
	JSR RDOB
	STA TMP0
RDOA2	RTS
;READ HEX BYTE AND RETURN IN A
;AND CY=0 IF SP CY=1
RDOB	LDA #0          ;SPACE
	STA BAD         ;READ NEXT CHAR
	JSR RDOC
	BEQ RDOB4       ;FAIL ON CR
	CMP #'          ;BLANK?
	BEQ RDOB        ;SPAN BLANKS...
;
	JSR HEXIT       ;CONVERT TO HEX NYBBLE
	ASL A
	ASL A
	ASL A
	ASL A
	STA BAD
	JSR RDOC        ;2ND CHAR ASSUMED HEX
	BEQ RDOB4       ;FAIL ON CR
	JSR HEXIT
	ORA BAD
;
RDOB4	RTS
.SKI 5
;CONVERT ASCII CHAR TO HEX NYBBLE
;
HEXIT	CMP #$3A
	PHP             ;SAVE FLAGS
	AND #$0F
	PLP
	BCC HEX09       ;0-9
	ADC #8          ;ALPHA ADD 8+CY=9
HEX09	RTS
.SKI 5
;GET CHARACTER AND TEST FOR CR
;
RDOC	JSR BASIN
	CMP #$0D        ;IS IT A CR
	RTS             ;RETURN WITH FLAGS
.SKI 5
;SEND DISK COMMAND OR READ STATUS
;
DISK	LDA #0          ;CLEAR STATUS @ I/O BEGIN
	STA STATUS
	STA FNLEN       ;FILENAME LENGTH OF ZERO...
;
	LDX DDISK       ;GET DEFAULT DISK
	LDY #$0F        ;OPEN COMMAND CHANNEL
	JSR SETLFS      ;.A-0 TEMPORARY CHANNEL #
	CLC
	JSR OPEN        ;OPEN A REAL CHANNEL
	BCS DISK30      ;EXIT IF BAD RETURN
;
	JSR RDOC        ;SEE IF STATUS CHECK
	BEQ DISK20      ;YES
;
	PHA
	LDX #0
	JSR CKOUT       ;SET UP AS OUTPUT
	PLA
	BCS DISK30      ;BAD STATUS RETURN
	BCC DISK15      ;NO...OK
;
DISK10	JSR BASIN       ;GET A CHARACTER
DISK15	CMP #$D         ;SEE IF END
	PHP             ;SAVE FOR LATER
	JSR BSOUT       ;OUT TO FLOPPY
	LDA STATUS
	BNE DISK28      ;BAD STATUS RETURNED
	PLP             ;END?
	BNE DISK10      ;NO...CONTINUE
	BEQ DISK30      ;YES...FLOPPY DONE
;
DISK20	JSR CRLF
	LDX #0
	JSR CHKIN       ;TELL FLOPPY TO SPEAK
	BCS DISK30      ;BAD DEVICE
;
DISK25	JSR RDOC        ;GET A CHARACTER
	PHP             ;SAVE TEST FOR LATER
	JSR BSOUT       ;OUT TO SCREEN
	LDA STATUS      ;CHECK FOR BAD BASIN
	AND #$FF-$40    ;REMOVE EOI BIT
	BNE DISK28      ;REPORT BAD STATUS
	PLP             ;END?
	BNE DISK25      ;NO...
	BEQ DISK30      ;YES...FLOPPY DONE
;
DISK28	PLA             ;CLEAN UP...
DISK29	JSR ERROR5      ;REPORT ERROR #5 FOR BAD DEVICE
DISK30	JSR CLRCH       ;CLEAN UP
	LDA #0
	CLC             ;JUST REMOVE FROM TABLE
	JMP CLOSE
.END
