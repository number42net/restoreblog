	*=$0000
;
; COPYRIGHT MOS TECHNOLOGY, INC. SEPT.,1976
; ALL RIGHTS RESERVED.	REV. 0
;
LEN	=17
XY	=$01
XZ	=$02
XM	=$03
XN	=$04
YX	=$10
YZ	=$12
YM	=$13
YN	=$14
ZX	=$20
ZY	=$21
ZM	=$23
ZN	=$24
MX	=$30
MY	=$31
MZ	=$32
MN	=$34
NX	=$40
NY	=$41
NZ	=$42
NM	=$43
N	*=*+1
NKON	*=*+1
J	*=*+1
CNT	*=*+1
LENGTH	*=*
CNTA	*=*+1
DEG	*=*+1
ARGXL	*=*+1
ARGXH	*=*+1
ARGYL	*=*+1
ARGYH	*=*+1
RES	*=*+2
PTR	*=*+2
KON	*=*+1
KONH	*=*+1
PREC	*=*+1
EXTRA	*=*+1
TEMP	*=*+1
TEMP1	*=*+1
OVERR	*=*+1
TMPX	*=*+1
TMPY	*=*+1
	*=$0200
RA	*=*+LEN+1
RB	*=*+LEN+1
RQ	*=*+LEN
RX	*=*
SX	*=*+LEN
EX	*=*+1
RY	*=*
SY	*=*+LEN
EY	*=*+1
RZ	*=*+0
SZ	*=*+LEN
EZ	*=*+1
RM	*=*+LEN+1
RN	*=*+LEN+1
RAMCOD	*=*+3
RAMA	*=*+3
RAMB	*=*+5
	*=$F800
;
; FLOATING POINT ADD-SUBTRACT ROUTINE.
;
SUB	LDA SY
	EOR #$80
	STA SY
ADD	LDA SX
	EOR SY
	STA TEMP
	SED
;
; CLEAR WORKING STORAGE.
;
	JSR CLEAR
;
; TEST RX FOR ZERO.
;
	JSR XZTST
;
; TEST RY FOR ZERO.
;
	BEQ ADD2
	JSR YZTST
	BEQ ADD3
	BIT TEMP
	BVC ADD6
;
; IF THE SIGNS OF THE EXPONENTS
; DIFFER THEN SWAP RX AND RY.
;
ADD1	BIT SX
	BVC ADD3
ADD2	JSR XSY
ADD3	SED
	BIT TEMP
	BVS ADD31
	JMP ADD9
ADD31	LDA EX
	CLC
	ADC EY
	BCS ADD5
ADD4	STA CNT
;
; COMPUTE THE HEX VALUE OF THE
; BCD DIFFERENCE OF THE EXPONENTS.
;
	JSR DECHEX
	CMP N
	BCS ADD5
;
; MOVE RY TO RB.
;
	JSR RBERY
;
; ALIGN DECIMAL POINTS.
;
	JSR RSBCNT
;
; ROUND RB OFF.
;
	JSR RBOFF
ADD5	LDA EX
	STA EZ
;
; MOVE RX TO RA.
; 
	JSR RAERX
	BIT TEMP
	BMI ADD13
;
; ADD RB TO RA.
	JSR RAPRB
	LDA RA
	BEQ ADD120
	JSR RSRA
;
; CORRECT SIGN AND EXPONENT.
;
	LDA EX
	SEC
	BIT SX
	BVC ADD110
	SBC #1
	STA EZ
	BNE ADD120
	LDA #$BF
	AND SX
	JMP ADD12
ADD120	LDA SX
ADD12	STA SZ
;
; MOVE RA TO RZ.
;
ADD121	JSR RZERA
	RTS
ADD110	ADC #0
	STA EZ
	BCC ADD120
;
; SET RZ=9.9...9E99
;
	JSR INFIN
	RTS
;
; COMPARE ABS(RX) TO ABS(RY)
;
ADD6	JSR COMPXY
	LDA CNTA
	BEQ ADD8
;
; SWAP RX AND RY,
; SO THAT RX HAS THE
; LARGEST ABS. VALUE.
;
ADD7	JSR XSY
ADD8	LDA EX
	CMP EY
	BEQ ADD81
	BCC ADD7
	JMP ADD1
ADD81	JMP ADD3
;
; COMPUTE THE ABSOLUTE VALUE
; OF THE SIGNED DIFFERENCE OF
; THE EXPONENTS.
;
ADD9	SEC
	BIT SX
	BVS ADD10
	LDA EX
	SBC EY
	JMP ADD4
ADD10	LDA EY
	SBC EX
	JMP ADD4
;
; SUBTRACT RB FROM RA.
;
ADD13	JSR RAMRB
	LDA EX
	STA EZ
	LDA SX
	STA SZ
;
; TEST RA FOR ZERO.
;
	JSR AZTST
	BEQ ADD18
ADD15	LDA RA+1
	BNE ADD121
;
; IF RA+1 IS ZERO THEN
; LEFT SHIFT RA ONE DIGIT.
;
	JSR LSRA
ADD17	BIT SZ
	SEC
	LDA EZ
	BVC ADD20
	ADC #0
	STA EZ
	BCC ADD15
;
; SET RZ EQUAL TO ZERO.
;
ADD18	JSR CLRZ
ADD19	RTS
;
; ADJUST SIGN AND EXPONENT
; OF THE ANSWER.
;
ADD20	SBC #1
	STA EZ
	BCS ADD15
	LDA #1
	STA EZ
	LDA #$40
	ORA SZ
	STA SZ
	JMP ADD15
;
; FLOATING POINT PRODUCT ROUTINE.
;
MLTPLY	SED
;
; CLEAR WORKING STORAGE.
;
	JSR CLEAR
	LDA #0
	STA CNT
	STA TEMP1
;
; TEST RA FOR ZERO.
;
	JSR XZTST
	BEQ MULT1
;
; TEST RY FOR ZERO.
;
	JSR YZTST
	BNE MULT3
;
; SET RZ EQUAL TO ZERO.
;
MULT1	JSR CLRZ
	RTS
;
; MOVE RA TO RZ.
;
MULT2	JSR RZERA
	RTS
;
; MOVE RY TO RB.
;
MULT3	JSR RBERY
;
; MOVE RX TO RQ.
;
	JSR RQERX
;
; FORM PRODUCT OF MANTISSAS.
;
	JSR MLT
;
; FIGURE THE SIGN AND EXPONENT OF
; OF THE ANSWER FOR THE MULTIPLY
; AND DIVIDE ROUTINES.
;
MULT4	LDA SY
	EOR SX
	STA TEMP
	BIT TEMP
	LDA EX
	BVS MD100
MD1	CLC
	ADC EY
	BCC MD2
	BNE MD59
	LDA TEMP1
	BEQ MDOV2
	BIT SX
	BVS MD7
	LDA CNTA
	BEQ MD61
	LDA #0
	STA CNTA
MDOV1	LDA #$99
	JMP MD2
MD100	JMP MD10
MDOV2	BIT SX
	BVC MD61
	LDA RA
	BEQ MDOV1
	JSR RSRA
	JMP MDOV1
MD2	STA EZ
	BNE MD11
	LDA SX
	AND #$BF
MD3	STA SZ
MD4	LDA TEMP
	BMI MD8
	LDA #$7F
	AND SZ
MD5	STA SZ
	LDA TEMP1
	BNE DIVEXT
	LDA RA
	BEQ MD51
	JSR RSRA
	LDA EZ
	BIT SZ
	BVS MD9
	CLC
	ADC #1
	BEQ MD6
	STA EZ
MD51	JMP MULT2
MD59	LDA SX
	STA SZ
MD6	BIT SZ
	BVS MD7
MD61	JSR INFIN
	RTS
MD7	JSR CLRZ
	RTS
MD8	LDA #$80
	ORA SZ
	JMP MD5
MD10	SEC
	SBC EY
	BCS MD2
	SEC
	LDA EY
	SBC EX
	STA EZ
	LDA SY
	JMP MD3
MD11	LDA SX
	JMP MD3
DIVEXT	LDA CNTA
	BEQ MD51
DVEXT0	BIT SZ
	LDA EZ
	SEC
	BVC DVEXT2
	ADC #0
	BEQ MD6
DVEXT1	STA EZ
	JMP MULT2
DVEXT2	BEQ DVEXT3
	SBC #1
	JMP DVEXT1
DVEXT3	LDA SZ
	ORA #$40
	STA SZ
	JMP DVEXT0
MD9	SEC
	SBC #1
	BEQ MD22
	STA EZ
	JMP MULT2
MD22	JMP MD2
;
; FLOATING POINT DIVIDE ROUTINE.
;
DIVIDE	SED
;
; TEST RY FOR ZERO.
;
	JSR YZTST
	BEQ MD61
;
; TEST RX FOR ZERO.
;
	JSR XZTST
	BEQ MD7
;
; CLEAR WORKING STORAGE.
;
	JSR CLEAR
;
; MOVE RX TO RA.
;
	JSR RAERX
;
; MOVE RY TO RB.
;
	JSR RBERY
;
; COMPARE RX TO RY.
;
	JSR COMPXY
;
; FORM QUOTIENT.
;
	JSR DIV
;
; COMPUTE SIGN AND EXPONENT OF
; ANSWER.
;
DIV6	LDA #1
	STA TEMP1
	LDA SY
	EOR #$40
	STA SY
	JSR RAERQ
	LDA RA+1
	BNE DIV7
	JSR LSRA
DIV7	JSR MULT4
	LDA SY
	EOR #$40
	STA SY
	RTS
;
; THIS ROUTINE COMPUTES THE
; PRODUCT OF THE MANTISSAS
; OF THE ARGUMENTS BY REPEATED
; ADDITION. THE RESULT IS BUILT
; IN RA.
;
MLT	LDA N
	STA J
	DEC J
MLT0	LDX J
	LDA RQ,X
	STA CNT
MLT1	DEC CNT
	BMI MLT2
	JSR RAPRB
	JMP MLT1
MLT2	JSR RSRA
	DEC J
	BPL MLT0
	JSR LSRA
	RTS
;
; THIS ROUTINE COMPUTES THE
; QUOTIENT OF RA AND RB BY
; REPEATED SUBTRACTION. THE
; RESULT IS BUILT IN RQ.
;
DIV	LDA #0
	STA J
DIV0	LDA #0
	STA CNT
DIV1	JSR RAMRB
	BCC DIV2
	INC CNT
	BNE DIV1
DIV2	JSR RAPRB
	JSR LSRA
	LDX J
	LDA CNT
	STA RQ,X
	INC J
	LDA J
	CMP N
	BEQ DIV0
	BCC DIV0
	RTS
;
; THIS ROUTINE COMPUTES THE
; SQUARE ROOT OF A FLOATING POINT
; NUMBER BETWEEN 1 AND 100 BY
; HERONS METHOD.
;
SQRT	LDA #7
	STA NKON
	JSR MVXN
	JSR CLRZ
	LDA #7
	STA RZ+1
	LDA #8
	STA RZ+2
	JSR MVZM
SQRT0	JSR MVMY
	JSR MVNX
	JSR DIVIDE
	JSR MVZY
	JSR MVMX
	JSR ADD
	JSR MVZX
	JSR CLRY
	LDA #$40
	STA RY
	LDA #5
	STA RY+1
	LDA #1
	STA EY
	JSR MLTPLY
	JSR MVZM
	DEC NKON
	BPL SQRT0
	RTS
;
; THIS ROUTINE COMPUTES THE
; COMMON LOG OF A FLOATING POINT
; NUMBER BETWEEN SQRT(.1)AND SQRT(10).
;
LOG	LDA #14
	STA N
	JSR SETKON
	JSR MVXN
	JSR CLRY
	LDA #1
	STA RY+1
	JSR SUB
	JSR MVNX
	JSR CLRY
	LDA #1
	STA RY+1
	JSR MVZN
	JSR ADD
	JSR MVZY
	JSR MVNX
	JSR DIVIDE
	JSR MVZN
	JSR MVZX
	JSR MVZY
	JSR MLTPLY
	LDA #4
	STA DEG
	LDA #0
LOGEND	STA NKON
	JSR POLY
	JSR MVNY
LGND0	JSR MVZX
	JSR MLTPLY
CHOP	LDA #0
	LDX #LEN/2-1
CHOP0	STA RZ+9,X
	DEX
	BPL CHOP0
	RTS
;
; THIS ROUTINE COMPUTES THE
; COMMON ANTI-LOG OF A FLOATING
; POINT NUMBER BETWEEN 0 AND 1.
;
TENX	LDA #12
	STA N
	JSR SETKON
	JSR MVXZ
	LDA #6
	STA DEG
	LDA #46
	STA NKON
	JSR POLY
	JSR MVZY
	JMP LGND0
;
; THIS ROUTINE COMPUTES THE
; TANGENT OF A FLOATING POINT NUMBER
; BETWEEN 0 AND PI/4.
;
TANX	LDA #14
	STA N
	JSR SETKON
	JSR MVXN
	JSR MVXY
	JSR MLTPLY
	JSR CHOP
	LDA #5
	STA DEG
	LDA #100
	JMP LOGEND
;
; THIS ROUTINE COMPUTES THE
; ARCTANGENT OF A FLOATING POINT NUMBER
; BETWEEN 0 AND 1.
;
ATANX	LDA #14
	STA N
	JSR SETKON
	JSR MVXN
	JSR MVXY
	JSR MLTPLY
	LDA #7
	STA DEG
	LDA #156
	JMP LOGEND
;
; LEFT SHIFT RA ONE DIGIT.
;
LSRA	LDX #0
LSRA0	LDA RA+1,X
	STA RA,X
	INX
	CPX N
	BCC LSRA0
	BEQ LSRA0
	LDA #0
	STA RA,X
	RTS
;
; RIGHT SHIFT RA ONE DIGIT.
;
RSRA	LDX N
	DEX
RSRA0	LDA RA,X
	STA RA+1,X
	DEX
	BPL RSRA0
	LDA #0
	STA RA
	RTS
;
; CLEAR WORKING STORAGE.
;
CLEAR	LDX #LEN*3+1
	LDA #0
AZ0	STA RA,X
	DEX
	BPL AZ0
	RTS
;
; CONVERT THE CONTENTS OF CNT
; FROM BCD TO HEX AND STORE THE
; RESULT IN CNT.
;
DECHEX	SED
	LDX #0
	SEC
DHCNV1	LDA CNT
	SBC #$16
	BCC DHCNV2
	STA CNT
	INX
	JMP DHCNV1
DHCNV2	CLD
	LDA CNT
	CMP #$0A
	BCC DHCNV3
	AND #$0F
	ADC #$09
DHCNV3	STX CNT
	ASL CNT
	ASL CNT
	ASL CNT
	ASL CNT
	ORA CNT
	STA CNT
	SED
DHCNVE	RTS
;
; RIGHT SHIFT RB CNT TIMES.
;
RSBCNT	LDA CNT
	BEQ RBOFE
	LDX N
RSBC	LDA RB,X
	STA RB+1,X
	DEX
	BPL RSBC
	LDA #0
	STA RB
	DEC CNT
	BNE RSBCNT
	RTS
;
; ROUND RB OFF.
;
RBOFF	LDX N
	LDA RB+1,X
	CMP #5
RBOF	LDA RB,X
	ADC #$90
	AND #$0F
	STA RB,X
	DEX
	BPL RBOF
RBOFE	RTS
;
; MOVE RY TO RB.
;
RBERY	LDX N
	DEX
RBRY	LDA RY+1,X
	STA RB+1,X
	DEX
	BPL RBRY
	RTS
;
; MOVE RX TO RA.
;
RAERX	LDX N
	DEX
RARX0	LDA RX+1,X
	STA RA+1,X
	DEX
	BPL RARX0
RARXE	RTS
;
; MOVE RX TO RQ.
;
RQERX	LDX N
	DEX
RQRX	LDA RX+1,X
	STA RQ,X
	DEX
	BPL RQRX
	RTS
;
; MOVE RQ TO RA.
;
RAERQ	LDX N
RARQ	LDA RQ,X
	STA RA+1,X
	DEX
	BPL RARQ
	RTS
;
; MOVE RA TO RZ.
;
RZERA	LDX N
	DEX
RZRA0	LDA RA+1,X
	STA RZ+1,X
	DEX
	BPL RZRA0
RZRAE	RTS
;
; ADD RB TO RA.
;
RAPRB	LDX N
	CLC
APB	LDA RA,X
	ADC RB,X
	ADC #$90
	AND #$0F
	STA RA,X
	DEX
	BPL APB
	RTS
;
; SUBTRACT RB FROM RA.
;
RAMRB	LDX N
	SEC
AMB	LDA RA,X
	SBC RB,X
	AND #$0F
	STA RA,X
	DEX
	BPL AMB
	RTS
;
; COMPARE RX TO RY.
;
COMPXY	LDA #0
	STA CNTA
	LDX N
	DEX
	SEC
COM1	LDA RX+1,X
	SBC RY+1,X
	DEX
	BPL COM1
	BCC COM2
	RTS
COM2	INC CNTA
	RTS
;
; TEST RA FOR ZERO.
;
AZTST	LDX N
	INX
AZTST0	LDA RA,X
	BNE XZTST1
	DEX
	BPL AZTST0
	BMI XZTST2
;
; TEST RX FOR ZERO.
;
XZTST	LDX N
XZTST0	LDA RX,X
	BNE XZTST1
	DEX
	BPL XZTST0
XZTST2	LDA #0
XZTST1	RTS
;
; TEST RY FOR ZERO.
;
YZTST	LDX N
YZTST0	LDA RY,X
	BNE XZTST1
	DEX
	BPL YZTST0	; *** NOTE: CHANGE 'BPL' TO 'BNE' ***
	BMI XZTST2	; *** NOTE: CHANGE 'BMI' TO 'BEQ' ***
;
; SWAP RX AND RY.
;
XSY	LDX #LEN
XSY1	LDA RX,X
	LDY RY,X
	STA RY,X
	TYA
	STA RX,X
	DEX
	BPL XSY1
	RTS
;
; SET RZ=9.9...9E99 AND OVERR=1.
;
INFIN	LDX N
	DEX
	LDA #9
INF0	STA RZ+1,X
	DEX
	BPL INF0
	LDA #$99
	STA EZ
	LDA #0
	STA SZ
	LDA #1
	STA OVERR
	RTS
;
; THE FOLLOWING ROUTINES ARE USED
; TO MOVE THE CONTENTS FROM ONE
; REGISTER TO ANOTHER, THE NAMES ARE
; OF THE FORM MVSD, WHERE S STANDS
; FOR SOURCE AND D FOR DESTINATION.
;
MVXY	LDA #XY
	BNE MVTR
MVXZ	LDA #XZ
	BNE MVTR
MVXM	LDA #XM
	BNE MVTR
MVXN	LDA #XN
	BNE MVTR
MVYX	LDA #YX
	BNE MVTR
MVYZ	LDA #YZ
	BNE MVTR
MVYM	LDA #YM
	BNE MVTR
MVYN	LDA #YN
	BNE MVTR
MVZX	LDA #ZX
	BNE MVTR
MVZY	LDA #ZY
	BNE MVTR
MVZM	LDA #ZM
	BNE MVTR
MVZN	LDA #ZN
	BNE MVTR
MVMX	LDA #MX
	BNE MVTR
MVMY	LDA #MY
	BNE MVTR
MVMZ	LDA #MZ
	BNE MVTR
MVMN	LDA #MN
	BNE MVTR
MVNX	LDA #NX
	BNE MVTR
MVNY	LDA #NY
	BNE MVTR
MVNZ	LDA #NZ
	BNE MVTR
MVNM	LDA #NM
MVTR	PHA
	LDX #11
MVTR0	LDA MOVR,X
	STA RAMCOD,X
	DEX
	BPL MVTR0
	PLA
	PHA
	AND #$0F
	TAX
	LDA TAB,X
	STA RAMB
	PLA
	LSR A
	LSR A
	LSR A
	LSR A
	TAX
	LDA TAB,X
	STA RAMA
	JMP RAMCOD
TAB	.BYTE $35,$47,$59,$6B,$7D
MOVR	LDX #LEN
MOVR0	LDA RX,X
	STA RY,X
	DEX
	BPL MOVR0
	RTS
;
; SET RX EQUAL TO ZERO.
;
CLRX	LDX #LEN
	LDA #0
CLRX0	STA RX,X
	DEX
	BPL CLRX0
	RTS
;
; SET RY EQUAL TO ZERO.
;
CLRY	LDX #LEN
	LDA #0
CLRY0	STA RY,X
	DEX
	BPL CLRY0
	RTS
;
; SET RZ EQUAL TO ZERO.
;
CLRZ	LDX #LEN
	LDA #0
CLRZ0	STA RZ,X
	DEX
	BPL CLRZ0
	RTS
;
; THIS ROUTINE IS USED TO LOOK UP
; THE COEFFICIENTS OF THE POLY-
; NOMIALS USED IN THE APPROXIMATIONS
; OF THE TRANSCENDENTAL FUNCTIONS.
;
LOOKUP	JSR CLRY
	LDX #0
	LDY NKON
	LDA (KON),Y
	STA SY
LKP0	INY
	LDA (KON),Y
	CMP #$F0
	BCS LKP1
	PHA
	AND #$0F
	STA RY+2,X
	PLA
	LSR A
	LSR A
	LSR A
	LSR A
	STA RY+1,X
	INX
	INX
	JMP LKP0
LKP1	AND #$0F
	STA EY
	INY
	STY NKON
	RTS
;
; THIS ROUTINE EVALUATES POLYNOMIALS
; BY MEANS OF THE NESTED MULTIPLICATION
; ALGORITHM.
;
POLY	JSR MVZM
	JSR MVZX
	JSR LOOKUP
POLY0	JSR MLTPLY
	JSR LOOKUP
	JSR MVZX
	JSR ADD
	JSR MVMX
	JSR MVZY
	DEC DEG
	BPL POLY0
	RTS
;
; THIS ROUTINE UNPACKS AN ARGUMENT
; AND STORES THE RESULT IN RZ.
;
PGTARG	LDX #0
	LDY #0
	LDA (PTR),Y
	STA SZ
PGTRG0	INY
	CPY LENGTH
	BEQ PGTRG1
	LDA (PTR),Y
	PHA
	AND #$0F
	STA RZ+2,X
	PLA
	LSR A
	LSR A
	LSR A
	LSR A
	STA RZ+1,X
	INX
	INX
	JMP PGTRG0
PGTRG1	LDA (PTR),Y
	STA EZ
	RTS
;
; THIS ROUTINE UNPACKS AN ARGUMENT
; LOCATED AT (ARGXL,ARGXH) AND STORES
; THE RESULTS IN RZ AND RX.
;
PLOADX	LDA ARGXL
	STA PTR
	LDA ARGXH
	STA PTR+1
	LDA PREC
	LSR A
	ADC #1
	STA LENGTH
	JSR CLRZ
	JSR PGTARG
	JSR MVZX
	RTS
;
; THIS ROUTINE UNPACKS AN ARGUMENT
; LOCATED AT (ARGYL,ARGYH) AND STORES
; THE RESULTS IN RY AND RZ.
;
PLOADY	LDA ARGYL
	STA PTR
	LDA ARGYH
	STA PTR+1
	LDA PREC
	LSR A
	ADC #1
	STA LENGTH
	JSR CLRZ
	JSR PGTARG
	JSR MVZY
	RTS
;
; THIS ROUTINE PACKS THE CONTENTS
; OF RZ INTO THE LOCATIONS STARTING
; WITH ADDRESS (RES,RES+1).
;
PSTRES	LDX #0
	LDY #0
	LDA SZ
	STA (RES),Y
	INY
PTRES	LDA RZ+1,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA RZ+2,X
	STA (RES),Y
	INY
	INX
	INX
	CPX PREC
	BCC PTRES
	LDA EZ
	STA (RES),Y
	RTS
;
; THIS ROUTINE CONVERTS AN ARGUMENT
; FROM ASCII FORMAT TO COMPUTATIONAL
; FORMAT AND STORES THE RESULT IN RZ.
;
UGTARG	LDY #0
	LDA (PTR),Y
	STA SZ
UGTAR0	INY
	CPY LENGTH
	BEQ UGTAR1
	LDA (PTR),Y
	AND #$0F
	STA RZ,Y
	JMP UGTAR0
UGTAR1	LDA (PTR),Y
	LSR A
	LSR A
	LSR A
	LSR A
	STA EZ
	INY
	LDA (PTR),Y
	AND #$0F
	ORA EZ
	STA EZ
	RTS
;
; THIS ROUTINE CONVERTS AN ARGUMENT
; FROM ASCII FORMAT TO COMP. FORMAT.
; THE ADDRESS OF THE ARG. IS FOUND IN
; (ARGXL,ARGXH) AND THE RESULT IS STORED
; IN RZ AND RX.
;
ULOADX	LDA ARGXL
	STA PTR
	LDA ARGXH
	STA PTR+1
	LDA PREC
	STA LENGTH
	INC LENGTH
	JSR CLRZ
	JSR UGTARG
	JSR MVZX
	RTS
;
; THIS ROUTINE CONVERTS AN ARGUMENT
; FROM ASCII FORMAT TO COMP. FORMAT.
; THE ADDRESS OF THE ARG. IS FOUND IN
; (ARGYL,ARGYH) AND THE RESULT IS
; STORED IN RZ AND RY.
;
ULOADY	LDA ARGYL
	STA PTR
	LDA ARGYH
	STA PTR+1
	LDA PREC
	STA LENGTH
	INC LENGTH
	JSR CLRZ
	JSR UGTARG
	JSR MVZY
	RTS
;
; THIS ROUTINE CONVERTS THE CONTENTS
; OF RZ TO ASCII FORMAT WHILE MOVING
; THEM TO THE ADDRESS SPECIFIED BY
; (RES,RES+1).
;
USTRES	LDY #0
	LDA SZ
	STA (RES),Y
USTRS0	INY
	CPY PREC
	BEQ USTRS1
	BCS USTRS2
USTRS1	LDA RZ,Y
	ORA #$30
	STA (RES),Y
	BNE USTRS0
USTRS2	INY
	LDA EZ
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$30
	STA (RES),Y
	INY
	LDA EZ
	AND #$0F
	ORA #$30
	STA (RES),Y
	RTS
;
; THIS ROUTINE COMPUTES THE
; INTERNAL PRECISION N FROM
; PREC AND EXTRA. THE ADD IS
; A BINARY ADD (UNSIGNED).
;
IPREC	CLC
	LDA PREC
	ADC EXTRA
	STA N
	RTS
;
; SAVE THE PROCESSOR INDEX REGISTERS.
;
SAVXY	STX TMPX
	STY TMPY
	RTS
;
; RECALL THE PROCESSOR INDEX REGISTERS.
;
RCLXY	LDX TMPX
	LDY TMPY
	RTS
KADDR	.WORD KONST
SETKON	LDA KADDR
	STA KON
	LDA KADDR+1
	STA KONH
	RTS
;
; THESE ARE THE COEFFICIENTS USED
; IN THE EVALUATION OF THE TRANSCENDENTAL
; FUNCTIONS.
;
KONST	.BYTE $40,$18,$20,$91,$29,$97,$F1
	.BYTE $40,$55,$34,$27,$38,$70,$F2
	.BYTE $40,$13,$13,$69,$01,$12,$10,$F1
	.BYTE $40,$17,$31,$09,$55,$17,$F1
	.BYTE $40,$28,$95,$51,$13,$02,$67,$F1
	.BYTE $40,$86,$85,$88,$74,$83,$40,$50,$F1
	.BYTE $40,$93,$26,$42,$67,$F4
	.BYTE $40,$25,$54,$91,$79,$60,$F3
	.BYTE $40,$17,$42,$11,$19,$88,$F2
	.BYTE $40,$72,$95,$17,$36,$66,$F2
	.BYTE $40,$25,$43,$93,$57,$48,$40,$F1
	.BYTE $40,$66,$27,$30,$88,$42,$90,$F1
	.BYTE $00,$11,$51,$29,$27,$76,$03,$F0
	.BYTE $00,$10,$F0
	.BYTE $40,$41,$09,$74,$19,$48,$F4
	.BYTE $40,$20,$31,$17,$10,$84,$F4
	.BYTE $40,$27,$97,$43,$35,$03,$70,$F3
	.BYTE $40,$98,$34,$59,$45,$39,$30,$F3
	.BYTE $40,$39,$86,$59,$10,$47,$05,$F2
	.BYTE $40,$16,$14,$89,$77,$76,$17,$40,$F1
	.BYTE $40,$78,$53,$98,$17,$62,$29,$10,$F1
	.BYTE $40,$28,$49,$88,$96,$20,$80,$F3
	.BYTE $C0,$16,$06,$86,$28,$96,$04,$F2
	.BYTE $40,$42,$69,$15,$19,$27,$11,$F2
	.BYTE $C0,$75,$04,$29,$45,$38,$89,$F2
	.BYTE $40,$10,$64,$09,$34,$02,$53,$F1
	.BYTE $C0,$14,$20,$36,$44,$46,$65,$20,$F1
	.BYTE $40,$19,$99,$26,$19,$39,$16,$60,$F1
	.BYTE $C0,$33,$33,$30,$73,$34,$50,$50,$F1
	.BYTE $40,$99,$99,$99,$98,$47,$65,$70,$F1
	.END
