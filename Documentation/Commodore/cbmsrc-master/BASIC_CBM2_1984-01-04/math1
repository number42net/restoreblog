.PAGE 'MATH CRACKING ROUTINES.'
FORFIX	;EMPTY SPACE FOR FUTURE FIXES
	.BYT $FF        ;CHECK SUM BYTE
;
PATCH1	JSR OLDCLR      ;CLEAR DISK STATUS FOR PRINTN & CMD
	JMP CHKOUT
PATCH2	JSR OLDCLR      ;CLEAR DISK STATUS FOR INPUTN & GET
	JMP CHKIN
PATCH3	SEC             ;CLOSE ALL FILES ASSOCIATED WITH DEVICE IN .A
	JMP KCLALL
 .BYT $FF,$FF,$FF
 .BYT $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 .BYT $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 .BYT $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 .BYT $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
 .SKI 2
;       THE FORMULA EVALUATOR STARTS WITH (TXTPTR) -> TO
;       THE 1ST CHAR OF THE FORMULA.
;       AT THE END (TXTPTR) -> TO THE TERMINATOR.
;       THE RESULT IS LEFT IN THE FAC.
;       ON RETURN (A) DOES NOT REFLECT THE TERMINATOR.
;       
;       THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB=
;       TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
;       EACH OPERATOR.
;       A TEM RESULT ON THE STK HAS THE FOLLOWING FORMAT
;       ADDRESS OF THE OPERATOR ROUTINE
;       FP TEMP RESULT
;       PRECEDENCE OF THE OPERATOR
FRMEVL	JMP (IFRMEV)
NFRMEV	LDX TXTPTR
	BNE FRMEV1
	DEC TXTPTR+1
FRMEV1	DEC TXTPTR
	LDX #0
	.BYTE $24
LPOPER	PHA
	TXA
	PHA
	LDA #1
	JSR GETSTK
	JSR EVAL
	LDA #0
	STA OPMASK
TSTOP	JSR CHRGOT
LOPREL	SEC
	SBC #TKGREA
	BCC ENDREL
	CMP #TKLESS-TKGREA+1
	BCS ENDREL
	CMP #1
	ROL A
	EOR #1
	EOR OPMASK
	CMP OPMASK
	BCC SNERR5
	STA OPMASK
	JSR CHRGET
	JMP LOPREL
;
ENDREL	LDX OPMASK
	BNE FINREL
	BCS QOP
	ADC #TKGREA-TKPLUS
	BCC QOP
	ADC VALTYP
	BNE *+5
	JMP CAT
;
	ADC #$FF
	STA INDEX1
	ASL A
	ADC INDEX1
	TAY 
QPREC	PLA
	CMP OPTAB,Y
	BCS QCHNUM
	JSR CHKNUM
DOPREC	PHA
NEGPRC	JSR DOPRE1
	PLA
	LDY OPPTR
	BPL QPREC1
	TAX
	BEQ QOPGO
	BNE PULSTK
FINREL	LSR VALTYP
	TXA
	ROL A
	LDX TXTPTR
	BNE FINRE2
	DEC TXTPTR+1
FINRE2	DEC TXTPTR
	LDY #PTDORL-OPTAB
	STA OPMASK
	BNE QPREC
QPREC1	CMP OPTAB,Y
	BCS PULSTK
	BCC DOPREC
DOPRE1	LDA OPTAB+2,Y
	PHA
	LDA OPTAB+1,Y
	PHA
	JSR PUSHF1
	LDA OPMASK
	JMP LPOPER
;
SNERR5	JMP SNERR
;
PUSHF1	LDA FACSGN
	LDX OPTAB,Y
PUSHF	TAY
	PLA
	STA INDEX1
	PLA
	STA INDEX1+1
	TYA
	PHA
	INC INDEX1      ;FIX 10/19/79
	BNE FORPSH      ;
	INC INDEX1+1
FORPSH	JSR ROUND
	LDA FACLO
	PHA
	LDA FACMO
	PHA
	LDA FACMOH
	PHA
	LDA FACHO
	PHA
	LDA FACEXP
	PHA
	JMP (INDEX1)
;
QOP	LDY #$FF
	PLA
QOPGO	BEQ QOPRTS
QCHNUM	CMP #100
	BEQ UNPSTK
	JSR CHKNUM
UNPSTK	STY OPPTR
PULSTK	PLA
	LSR A
	STA DOMASK
	PLA
	STA ARGEXP
	PLA
	STA ARGHO
	PLA
	STA ARGMOH
	PLA
	STA ARGMO
	PLA
	STA ARGLO
	PLA
	STA ARGSGN
	EOR FACSGN
	STA ARISGN
QOPRTS	LDA FACEXP
	RTS
.SKIP 1
EVAL	JMP (IEVAL)
NEVAL	LDA #0
	STA VALTYP
EVAL0	JSR CHRGET
	BCS EVAL2
EVAL1	JMP FIN
;
EVAL22
	CMP #PI
	BNE QDOT
	LDA #<PIVAL
	LDY #>PIVAL
	JSR MOVFM
	JMP CHRGET
;
PIVAL	.BYTE $82,$49,$0F,$DA,$A1
;
EVAL2	JSR ISLETC
	BCC EVAL22
	BCS ISVAR
.SKIP 4
QDOT	CMP #'.'
	BEQ EVAL1
	CMP #TKMINU
	BEQ DOMIN
	CMP #TKPLUS
	BEQ EVAL0
	CMP #34
	BNE EVAL3
STRTXT	JSR SAV30
	JSR STRLIT
	JMP ST2TXT
;
EVAL3	CMP #TKNOT
	BNE EVAL4
	LDY #NOTTAB-OPTAB
	BNE GONPRC
NOTOP	JSR AYINT
	LDA FACLO
	EOR #$FF
	TAY
	LDA FACMO
	EOR #$FF
	JMP GIVAYF
;
EVAL4	CMP #TKFN
	BNE *+5
	JMP FNDOER
;
EVAL5
	CMP #TKONEF
	BCC PARCHK
	CMP #TKERRD     ;COVER ERR$ & INSTR$
	BCS EVAL6
	CMP #TKGO       ;CAN'T BE RESERVED WORD PAST STR FTNS
	BCS SNERR
EVAL6	JMP ISFUN
.SKI 4
DOMIN	LDY #NEGTAB-OPTAB
GONPRC	PLA
	PLA
	JMP NEGPRC
.SKIP 4
PARCHK	JSR CHKOPN
	JSR FRMEVL
CHKCLS	LDA #')'        ;CHECK FOR ')'
	.BYTE $2C       ;EAT THE NEXT TWO BYTES
CHKOPN	LDA #'('        ;CHECK FOR '('
	.BYTE $2C       ;EAT THE NEXT TWO BYTES
CHKCOM	LDA #','
;
;
;       LOOKS AT THE CURRENT CHAR TO MAKE SURE IT
;       IS THE SPECIFIC THING LOADED INTO ACCA JUST
;       BEFORE THE CALL TO SYNCHK.
;       IF NOT IT CALLS THE SYNTAX ERROR ROUTINE.
;       OTHERWISE IT EATS THE NEXT CHAR AND RETURNS
;
;       NOTE, I6509 IS SAVED AND RESTORED BY SYNCHR!
SYNCHR
	STA TTTEMP
	LDY I6509
	STY TTTEMP+1
	LDY TXTPTR+2
	STY I6509
	LDY #0
	LDA (TXTPTR)Y
	LDY TTTEMP+1
	STY I6509
	CMP TTTEMP
	BNE SNERR       ;IF NOT =, THEN ERROR
	JMP CHRGET      ;EAT CHAR
;
;       OUTPUT SYNTAX ERROR
SNERR	LDX #ERRSN
	JMP ERROR
.SKIP 4
;
;   ISVAR SETS UP THE VALUE OF THE VARIABLE EXPRESSION
;   IN THE FLOATING ACCUMULATOR. IF IT IS AN INTEGER,
;   THE VALUE IS FLOATED; IF IT IS A STRING, FAC HOLDS
;   A POINTER TO THE STRING'S DESCRIPTOR.
;
;   NOTE, SYMBOL TABLE SPACE FOR UNINITIALIZED VARIABLES
;   IS NEVER ALLOCATED. FOR THESE AND BASIC RESERVED
;   VARS, "PTRGET" RETURNS A POINTER TO "ZERO",STORED
;   IN BASIC'S ROM AREA. "ISVAR" CHECKS THE VAR NAME
;   AND TYPE FOR THESE SPECIAL CASES. IF NOT A RESERVED
;   VAR, "ISVAR" USES "ZERO" TO CREATE A NUMERIC ZERO
;   OR NULL STRING VALUE.
;
ISVAR
	JSR PTRGET
ISVRET
	STA FACMO
	STY FACMO+1
	STX FACMO+2
	LDX VARNAM
	LDY VARNAM+1
	LDA VALTYP
	BEQ GOO
	LDA #0
	STA FACOV
	JSR TSTROM      ;TEST IF IN ROM
	BCS ISVRTS      ;NO...
	CPX #'T'
	BNE ISVDS       ;IF NOT 'T'
	CPY #$C9        ;'I'+$80
	BNE STRRTS      ;IF 'T' BUT NOT 'TI$'
	JMP GETTIM      ;GET TIME
;
ISVDS
	CPX #'D'
	BNE STRRTS      ;IF NOT 'D'
	CPY #$D3        ;'S'+$80
	BNE STRRTS      ;IF NOT 'DS$'
	JSR CHKDS
	LDA DSDESC+1
	LDY DSDESC+2
	LDX DSDESC+3
	JMP STRLIT
;
STRRTS	LDA MEMTOP      ;FACMO<-ADDR OF USER "ZERO"
	STA FACMO
	LDA MEMTOP+1
	STA FACMO+1
	LDA MEMTOP+2
	STA FACMO+2
ISVRTS	RTS
;
CHKDS	LDA DSDESC
	BNE ISVRTS
	JMP ERRCHL      ;GET STATUS
;
GOO	BIT INTFLG      ;TEST SIGN
	BPL GOOO
	LDA FACMO+2     ;SET INDIR BANK
	STA I6509
	LDY #0
	LDA (FACMO)Y
	TAX
	INY
	LDA (FACMO)Y
	TAY
	JSR MAPTXT
	TXA
	JMP GIVAYF
;
GOOO
	JSR TSTROM      ;TEST IF IN ROM
	BCC QSTATV      ; ...YES
	LDA FACMO
	LDY FACMO+1
	LDX FACMO+2
	JMP MOVFUM      ; FAC <- USER MEM
;
; PREVENT TI AS A USER-DEFD VAR
; CPX #'T'
; BNE QSTATV ;IF NOT 'T'
; CPY #'I'
; BNE GOMOVF ;IF 'T' BUT NOT 'TI'
; JMP SNERR
;
QSTATV	CPX #'S'
	BNE QERLIN      ;IF NOT 'S'
	CPY #'T'
	BNE QERLIN      ;IF 'S' BUT NOT 'ST'
	JSR READST      ;GET I/O STATUS BYTE
	JMP FLOAT
;
QERLIN	CPX #'E
    BNE QDSAV
    CPY #'R
   BEQ GNUMER
   CPY #'L
   BNE QDSAV
   LDA ERRLIN+1
   LDY ERRLIN
   JMP NOSFLT ;PRINT 2 BYTES
GNUMER	LDA ERRNUM
   LSR A ;DIVIDE BY 2
   JMP FLOAT  ;PRINT 1 BYTE
;
QDSAV	CPX #'D'
	BNE GOMOVF      ;IF NOT 'D'
	CPY #'S'
	BNE GOMOVF      ;IF 'D' BUT NOT 'DS'
	JSR CHKDS
	JSR MAPSTR      ;ASSUME STRING BANK!
	LDY #0
	LDA (DSDESC+1)Y
	AND #$F
	ASL A
	STA GARBFL
	ASL A
	ASL A
	ADC GARBFL
	STA GARBFL
	INY
	LDA (DSDESC+1)Y
	JSR MAPTXT
	AND #$F
	ADC GARBFL
	JMP FLOAT
;
GOMOVF	LDA FACMO       ; FAC<-ROM MEM (UNINIT. FLT VAR)
	LDY FACMO+1
	JMP MOVFM
.SKIP 4
ISFUN	ASL A
	PHA
	TAX
	JSR CHRGET
	CPX #TKLASN+TKLASN-$FF
	BCC OKNORM
TKERD2=TKERRD+TKERRD
	CPX #<TKERD2
	BEQ ERRJMP
	JSR CHKOPN
	JSR FRMEVL
	JSR CHKCOM
	JSR CHKSTR
	PLA
TKINT2=TKINST+TKINST
  CMP #<TKINT2
  BEQ INSJMP
	TAX
	LDA FACMO+2     ; PUSH DESCR PTR FOR OPND1
	PHA
	LDA FACMO+1
	PHA
	LDA FACMO
	PHA
	TXA
	PHA
	JSR GETBYT      ;OPND2
	PLA
	TAY
	TXA
	PHA
	JMP FINGO
;
OKNORM	JSR PARCHK
	PLA
	TAY
FINGO	LDA FUNDSP-TKONEF-TKONEF+256,Y
	STA JMPER+1
;
	LDA FUNDSP-TKONEF-TKONEF+257,Y
	STA JMPER+2
;
	JSR JMPER
	JMP CHKNUM
;
OROP	LDY #$FF
	.BYTE $2C       ;EAT THE NEXT TWO BYTES
ANDOP	LDY #0
	STY EORMSK
	JSR AYINT
	LDA FACMO
	EOR EORMSK
	STA INTEGR
	LDA FACLO
	EOR EORMSK
	STA INTEGR+1
	JSR MOVFA
	JSR AYINT
	LDA FACLO
	EOR EORMSK
	AND INTEGR+1
	EOR EORMSK
	TAY
	LDA FACMO
	EOR EORMSK
	AND INTEGR
	EOR EORMSK
	JMP GIVAYF
INSJMP	JMP INSTRG
ERRJMP	JMP ERRD
.SKIP 4
;       PERFORM RELATIONAL OPERATOR
;       (DOMASK) CONTAINS THE BITS AS TO WHICH RELATIONAL
;       OPERATOR IT WAS. CBIT SET = STRING COMPARE.
DOREL	JSR CHKVAL
	BCS STRCMP
	LDA ARGSGN      ;CONV ARG TO BASIC INTERNAL FORM
	ORA #127
	AND ARGHO
	STA ARGHO
	LDA #<ARGEXP
	LDY #>ARGEXP
	JSR FCOMP       ; ARG IS 1ST OPND
	TAX
	JMP QCOMP
;
STRCMP	LDA #0
	STA VALTYP
	DEC OPMASK
	JSR FREFAC      ;FREE STRING2
	STA DSCTMP      ; DSCTMP <- LENGTH2,
	LDX #2
GRRK
	LDA INDEX,X
	STA DSCTMP+1,X
	DEX
	BPL GRRK
	LDA ARGMO
	LDY ARGMO+1
	LDX ARGMO+2
	JSR FRETMP      ;FREE STRING1
	LDX INDEX
	LDY INDEX+1
	STX ARGMO       ;ARGMO<-PTR TO STRING1
	STY ARGMO+1
	LDY INDEX+2
	STY ARGMO+2
	TAX             ;.X <- LENGTH1
	SEC
	SBC DSCTMP
	BEQ STASGN      ; LENGTH1=LENGTH2
	LDA #1
	BCC STASGN      ; LENGTH1<LENGTH2
	LDX DSCTMP
	LDA #$FF
;      .A = O(EQUAL), 1(LEN1<LEN2), -1(LEN1>LEN2)
;      .X = LENGTH OF SHORTER STRING
STASGN	STA FACSGN
	JSR MAPDST      ;BANK:=DSCTMP+3
	LDY #$FF
	INX
NXTCMP	INY             ;.Y=INX TO NXT CHR, .X=#CHRS TO GO
	DEX
	BNE GETCMP
	LDX FACSGN
;    COME HERE WHEN STRINGS ARE EQUAL, BUT
;    .X =  1, LEN1<LEN2, CY=1
;          0, LEN1=LEN2, CY=0
;         -1, LEN1>LEN2, CY=0
QCOMP	BMI DOCMP
	CLC
	BCC DOCMP
GETCMP	LDA (DSCTMP+1)Y ; CHR FROM STRING2 (I6509 SET)
	STA TTTEMP
	LDA (ARGMO)Y    ; CHR FROM STRING1
	CMP TTTEMP
	BEQ NXTCMP
	LDX #$FF
	BCS DOCMP
	LDX #1
DOCMP	JSR MAPTXT
	INX
	TXA
	ROL A
	AND DOMASK
	BEQ GOFLOT
	LDA #$FF
GOFLOT	JMP FLOAT
.SKIP 4
PTRGET	LDX #0
	JSR CHRGOT
PTRGT1	STX DIMFLG
PTRGT2	STA VARNAM
	JSR CHRGOT
	JSR ISLETC
	BCS PTRGT3
INTERR	JMP SNERR
;
PTRGT3	LDX #0
	STX VALTYP
	STX INTFLG
	JSR CHRGET
	BCC ISSEC
	JSR ISLETC
	BCC NOSEC
ISSEC	TAX
EATEM	JSR CHRGET
	BCC EATEM
	JSR ISLETC
	BCS EATEM
NOSEC	CMP #'$'
	BNE NOTSTR
	LDA #$FF
	STA VALTYP
	BNE TURNON
NOTSTR	CMP #'%'
	BNE STRNAM
	LDA SUBFLG
	BNE INTERR
	LDA #$80
	STA INTFLG
	ORA VARNAM
	STA VARNAM
TURNON	TXA
	ORA #$80
	TAX
	JSR CHRGET
STRNAM	STX VARNAM+1
	SEC
	ORA SUBFLG
	SBC #40
	BNE *+5
	JMP ISARY
;
	LDY #0
	STY SUBFLG
	LDA VARTAB
	LDX VARTAB+1
STXFND	STX LOWTR+1
LOPFND	STA LOWTR       ;REACHED END OF SIMPLE VARS?
	.IFN CC4 <
	CPX VAREND+1    ;256K
	BNE LOPFN
	CMP VAREND      ;256K
>
	.IFN CC3 <
	CPX STREND+1    ;192K
	BNE LOPFN
	CMP STREND      ;192K
>
	.IFN CC1+CC2 <
	CPX ARYTAB+1    ;64K OR 128K
	BNE LOPFN
	CMP ARYTAB      ;64K OR 128K
>
	BEQ NOTFNS
LOPFN	JSR MAPVAR
	LDA (LOWTR)Y
	CMP VARNAM
	BNE NOTIT
	INY
	LDA (LOWTR)Y
	CMP VARNAM+1
	BNE NXTPTR
	JMP FINPTR
;
GOBADV	BEQ INTERR
;
NXTPTR	DEY
NOTIT	JSR MAPTXT
	CLC
	LDA LOWTR
	ADC #6+ADDPRC
	BCC LOPFND
	INX
	BNE STXFND
ISLETC	CMP #'A'
	BCC ISLRTS
	SBC #$5B
	SEC
	SBC #$A5
ISLRTS	RTS
;
NOTFNS	PLA
	PHA
ISVRM1=ISVRET-1
	CMP #<ISVRM1
	BNE NOTEVL
	TSX
	LDA $102,X
	CMP #>ISVRM1
	BNE NOTEVL
LDZR	LDA #<ZERO
	LDY #>ZERO
	LDX #SYSBNK
	RTS
;
NOTEVL	LDA VARNAM
	LDY VARNAM+1
	CMP #'T'
	BNE QSTAVR
	CPY #$C9        ;'I'+$80
	BEQ LDZR
;; CPY #'I'
;; BNE QSTAVR
;;GOBADV JMP SNERR
;
QSTAVR	CMP #'S'
	BNE QERAVR
	CPY #'T'
	BEQ GOBADV
QERAVR	CMP #'E
   BNE QDSVAR
   CPY #'R
   BEQ GOBADV
   CPY #'L
   BEQ GOBADV
;
QDSVAR	CMP #'D'        ;DISK STATUS?
	BNE VAROK
	CPY #'S'
	BEQ GOBADV      ;CANNOT MODIFY DS
	CPY #$D3        ;'S'+$80
	BEQ GOBADV      ;CANNOT MODIFY DS$
VAROK
	.IFN CC4 <
	LDA VAREND      ;END OF SIMPLE VARS (256K)
	LDY VAREND+1
>
	.IFN CC3 <
	LDA STREND      ;END OF SIMPLE VARS (192K)
	LDY STREND+1
>
	.IFN CC3+CC4 <
	STA LOWTR       ;^TO START OF NEW VARIABLE
	STY LOWTR+1
	CLC
	ADC #6+ADDPRC
	BCC GOBLT
	INY
GOBLT	JSR BLTUV       ;ENOUGH ROOM?
>
	.IFN CC1+CC2 <
	LDA ARYTAB      ;END OF SIMPLE VARS (64K,128K)
	LDY ARYTAB+1
	STA LOWTR
	STY LOWTR+1
	LDA STREND
	LDY STREND+1
	STA HIGHTR
	STY HIGHTR+1
	CLC
	ADC #6+ADDPRC
	BCC NOTEVE
	INY
NOTEVE	STA HIGHDS
	STY HIGHDS+1
>
	.IFN CC1 <
	JSR BLTU        ;64K
>
	.IFN CC2 <
	JSR BLTUV       ;128K
>
	.IFN CC1+CC2 <
	LDA HIGHDS      ;64K OR 128K
	LDY HIGHDS+1
	INY
	STA ARYTAB
	STY ARYTAB+1
	STA ARYPNT      ;SET POINTER TO ARRAYS
	STY ARYPNT+1
ARYVA2	LDA ARYPNT
	LDX ARYPNT+1
ARYVA3	CPX STREND+1    ;END OF ARRAYS ?
	BNE ARYVGO
	CMP STREND
	BNE ARYVGO
	JMP ARYDON      ;FINISHED...
ARYVGO	STA INDEX1      ;PARSE THE ARRAY
	STX INDEX1+1
	JSR MAPVAR
	LDY #1-ADDPRC
	LDA (INDEX1)Y   ;ARRAY NAME
	TAX
	INY
	LDA (INDEX1)Y   ;NAME 2ND CHAR
	PHP             ;SAVE STATUS REG
	INY
	LDA (INDEX1)Y   ;POINT TO NEXT ARRAY
	ADC ARYPNT
	STA ARYPNT
	INY
	LDA (INDEX1)Y
	ADC ARYPNT+1
	STA ARYPNT+1
	PLP             ;RESTORE STATUS
	BPL ARYVA2      ;NOT A STRING TYPE
	TXA
	BMI ARYVA2      ;NOT A STRING ARRAY
	INY             ;OK WE HAVE A STRING ARRAY
	LDA (INDEX1)Y
	LDY #$00
	ASL A
	ADC #5
	ADC INDEX1
	STA INDEX1
	BCC ARYGET
	INC INDEX1+1
ARYGET	LDX INDEX1+1    ;PARSE ARRAY
	CPX ARYPNT+1    ;DONE WITH THIS ARRAY ?
	BNE GOGO
	CMP ARYPNT
	BEQ ARYVA3      ;YES...
GOGO	JSR MAPVAR
	LDY #$00        ;PROCESS STRING POINTER
	LDA (INDEX1)Y
	BEQ DVARTS      ;NO STRING...GO ON...
	STA TTTEMP
	INY
	LDA (INDEX1)Y
	CLC
	ADC TTTEMP
	STA HIGHTR
	TAX             ;SAVE IS X FOR CHECK
	INY
	LDA (INDEX1)Y
	ADC #$00        ;ADJUST HIGH BYTE
	STA HIGHTR+1
	INY
	LDA (INDEX1)Y
	STA I6509       ;BANK SET FOR GETTING STRINGS
;       FIX BACKWARDS POINTER BY ADDING
;       THE MOVE LENGTH TO IT
	CLC
	LDY #$00
	LDA (HIGHTR)Y
	ADC #6+ADDPRC
	STA (HIGHTR)Y
	INY
	LDA (HIGHTR)Y
	ADC #$00
	STA (HIGHTR)Y   ;DONE WITH THIS STR.
;       FIX THE NEXT STRING IN THE ARRAY
DVARTS	LDA #STRSIZ
	CLC
	ADC INDEX1
	STA INDEX1
	BCC ARYGET
	INC INDEX1+1
	BNE ARYGET      ;BRANCH ALWAYS
;       
ARYDON
>
	JSR MAPVAR
	LDY #0
	LDA VARNAM
	STA (LOWTR)Y
	INY
	LDA VARNAM+1
	STA (LOWTR)Y
	LDA #0
	INY
	STA (LOWTR)Y
	INY
	STA (LOWTR)Y
	INY
	STA (LOWTR)Y
	INY
	STA (LOWTR)Y
	INY
	STA (LOWTR)Y
FINPTR
	JSR MAPTXT
	LDA LOWTR
	CLC
	ADC #2
	LDY LOWTR+1
	BCC FINNOW
	INY
FINNOW	STA VARPNT
	STY VARPNT+1
	LDX #VARBNK
	STX VARPNT+2
	RTS
.END
