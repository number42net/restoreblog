.PAG 'BVERBS1'
;   PROCESS LIST VERB
;
LIST
	JSR RANGE       ;SET UP LINE RANGE
	BNE LSTEND      ;OK...
	RTS             ;SOME BAD PARAMS, DO NOTHING
;
LSTEND	PLA
	PLA
;
LIST4
	LDY #1
	STY DORES
	LDA (LOWTR)Y
	BNE LIST44
	DEY
	LDA (LOWTR)Y
	BEQ GRODY
LIST44	LDY #1
	JSR KSTOP
	BNE LIST5       ;IF NO STOP REQUESTED
	CLC             ;NO BRK MSG DESIRED FOR...
	JMP STOPC       ;...PROCESS STOP
;
LIST5
	JSR OCRLF       ;NEW LINE
	INY
	LDA (LOWTR)Y
	TAX
	INY
	LDA (LOWTR)Y
	CMP LINNUM+1
	BNE TSTDUN
	CPX LINNUM
	BEQ TYPLIN
;
TSTDUN	BCS GRODY
TYPLIN	STY LSTPNT
	JSR LINPRT
	LDA #$20
PRIT4	LDY LSTPNT
	AND #$7F
PLOOP	JSR OCHR
	CMP #'"
	BNE PLOOP1
	LDA DORES
	EOR #$FF
	STA DORES
PLOOP1	INY
	BEQ GRODY
	LDA (LOWTR)Y
	BNE QPLOP
	TAY
	LDA (LOWTR)Y
	TAX
	INY
	LDA (LOWTR)Y
	STX LOWTR
	STA LOWTR+1
	JMP LIST4
GRODY	JMP READY
QPLOP	JMP (IQPLOP)
NQPLOP	BPL PLOOP
	CMP #PI
	BEQ PLOOP
	BIT DORES
	BMI PLOOP
	TAX
	STY LSTPNT
	LDY #>RESLST
	STY INDEX1+1
	LDY #<RESLST
	STY INDEX1
	LDY #0
PLOP20	ASL A
	BEQ PRIT3B
.SKI 4
;   POINT INDEX1 AT START OF WORD
RESRCH	DEX
	BPL PRIT3
RESCR1	INC INDEX1
	BNE RESCR2
	INC INDEX1+1
RESCR2	JSR LDI1Y
	BPL RESCR1
	BMI RESRCH
.SKI 4
;   LIST WORD INDEXING BY Y
PRIT3	INY
PRIT3B	JSR LDI1Y
	BMI PRIT4
	JSR OCHR
	BNE PRIT3
.PAG
;   PROCESS NEW AND CLR COMMANDS.
;
;   SCRTCH RESETS TEXT AREA.
;   CLEARC RESETS DATA AREAS.
;
SCRATH	BNE STKRTS
SCRTCH	LDA #0
	TAY
	STA (TXTTAB)Y
	INY
	STA (TXTTAB)Y
	CLC
	LDA TXTTAB
	ADC #2
	.IFN CC1 <
	STA VARTAB
	LDA TXTTAB+1
	ADC #0
	STA VARTAB+1
>
	.IFN CC2+CC3+CC4 <
	STA TXTEND
	LDA TXTTAB+1
	ADC #0
	STA TXTEND+1
>
;
RUNC	JSR STXTPT
	LDA #0
;
; CLEARC: (64K) STREND:=ARYTAB:=VARTAB
;        (128K) STREND:=ARYTAB:=VARTAB
;        (192K) STREND:=VARTAB, ARYEND:=ARYTAB
;        (256K) VAREND:=VARTAB, ARYEND:=ARYTAB
CLEAR
	BNE STKRTS
CLEARC
	JSR SETTOP      ;SET TOP OF MEMORY
	LDA #$FF        ;INDICATE NO ERROR TRAP VECTOR
	STA TRAPNO+1
	LDX #PUMONY-PUCHRS ;RESET PRINT USING CHARS
CLRPU	LDA PUDEFS,X
	STA PUCHRS,X
	DEX
	BPL CLRPU
	LDA #SYSBNK
	STA DFBANK      ;SET DEFAULT TO SYSTEM BANK#
	LDA #0
	STA DSDESC      ;CLEAR DS$
	JSR CLALL
	LDA VARTAB
	LDY VARTAB+1
	.IFN CC4 <
	STA VAREND      ;ONLY 256K
	STY VAREND+1
>
	.IFN CC1+CC2+CC3 <
	STA STREND      ;EXCEPT 256K
	STY STREND+1
>
	.IFN CC1+CC2 <
	STA ARYTAB      ;ONLY 64K,128K
	STY ARYTAB+1
>
	.IFN CC3+CC4 <
	LDA ARYTAB      ;ONLY 192K,256K
	LDY ARYTAB+1
	STA ARYEND
	STY ARYEND+1
>
;
FLOAD	JSR RESTO1
;
;   RESET STK, CLEAR OLTXT AND CURRENT CHANNEL
STKINI	LDX #0
	STX TEMPPT
	PLA 
	TAY
	PLA             ;GET CALLERS ADDRESS
	LDX #$FE        ;RESET STACK (LEAVE $01FF FREE)
	TXS
	PHA
	TYA
	PHA             ;RESTORE CALLER'S ADDRESS
	LDA #0
	STA OLDTXT
	STA OLDTXT+1
	STA CHANNL      ;CLEAR OUT CHANNEL
	STA DOLU
	STA SUBFLG
STKRTS	RTS
.SKI 3
PUDEFS	.BYTE ' ,.$'    ;DEFAULT FILL,COMMA,DEC PT,MONEY SYMBOLS
.PAG
;   A 'FOR' ENTRY ON THE STK HAS THE FOLLOWING FORMAT
;   USING SP RELATIVE OFFSETS:
;
;    (17-18) TXTPTR VALUE TO END OF FOR-STMT
;    (15-16) LINE NUMBER OF FOR-STMT
;    (10-14) LIMIT VALUE, IN BASIC FLOATING FORM
;    (04-09) STEP VALUE, IN FAC FLOATING FORM
;    (01-03) PTR TO FOR-VAR'S DATA AREA
;    (00)    TKFOR TOKEN
;
;   THIS CODE CREATES A NEW FOR-ENTRY ON THE STACK.
;   NOTE, RETURN TO THE CALLER OF "FOR" IS CLEARED AND
;   CONTROL JUMPS TO NEWSTT. ACTIVE FOR-LOOPS BETWEEN THIS
;   AND AN OLDER LOOP OF THE SAME FOR-VARIABLE ARE CLEARED
;   OFF.
;
FOR
	LDA #128
	STA SUBFLG      ;INTEGER FOR-VARS ILLEGAL
	JSR LET         ;FOR-VAR <- INITIAL VALUE
	JSR FNDFOR      ;POP OFF REDUNDANT ENTRIES
	BNE NOTOL
	TXA
	ADC #FORSIZ-3
	TAX
	TXS
NOTOL	PLA
	PLA
	LDA #8+ADDPRC
	JSR GETSTK
	JSR DATAN
	CLC
	TYA
	ADC TXTPTR      ;PTR TO END-OF-FOR-STMT
	PHA
	LDA TXTPTR+1
	ADC #0
	PHA
	LDA CURLIN+1    ;LINE NUMBER
	PHA
	LDA CURLIN
	PHA
	LDA #TKTO
	JSR SYNCHR      ;CHECK FOR 'TO' TOKEN
	JSR CHKNUM
	JSR FRMNUM      ;COMPUTE LIMIT, ROUND
	LDA FACSGN
	ORA #127
	AND FACHO
	STA FACHO
	LDA #<LDFONE    ;RETURN FROM FORPSH
	LDY #>LDFONE
	STA INDEX1
	STY INDEX1+1
	JMP FORPSH
LDFONE	LDA #<FONE      ;"ONE",DEFAULT STEP
	LDY #>FONE
	JSR MOVFM
	JSR CHRGOT
	CMP #TKSTEP
	BNE ONEON       ;NO STEP GIVEN...
	JSR CHRGET
	JSR FRMNUM      ;COMPUTE STEP VALUE
ONEON	JSR SIGN
	JSR PUSHF
	LDA FORPNT+2    ;FOR-VAR POINTER
	PHA
	LDA FORPNT+1
	PHA
	LDA FORPNT
	PHA
	LDA #TKFOR      ;FOR TOKEN
	PHA
	JMP NEWSTT      ;GET NEW STATEMENT
.PAG
NEXT	BNE GETFOR
	LDX #$FF        ;GARBAGE BANK#
	BMI STXFOR      ;ALWAYS
GETFOR	JSR PTRGET
STXFOR	JSR SAV74
	JSR FNDFOR
	BEQ HAVFOR
	LDX #ERRNF
	JMP ERROR
;
HAVFOR	TXS
	TXA
	CLC
	ADC #2+PTRSIZ   ; OFFSET TO STEP VA LUE
	PHA
	ADC #5+ADDPRC
	STA INDEX2      ;OFFSET TO LIMIT VALUE
	PLA
	LDY #1
	JSR MOVFM       ;FAC<-STEP VALUE
	TSX
	LDA ADDPRC+265,X
	STA FACSGN
	LDA FORPNT
	LDY FORPNT+1
	LDX FORPNT+2
	JSR UCNUPK      ;ACC <- FOR VALUE
	JSR FADDT
	JSR MOVVF       ;FOR VAR=FOR VAR+STEP
	LDY #1
	JSR FCOMPN      ;COMPARE TO LIMIT
	TSX
	SEC             ;CORRECT RESULTS FOR SIGN
	SBC ADDPRC+265,X
	BEQ LOOPDN
	LDA 270+ADDPRC+ADDPRC,X
	STA CURLIN      ;NOT DONE, REPEAT...
	LDA 271+ADDPRC+ADDPRC,X
	STA CURLIN+1
	LDA 273+ADDPRC+ADDPRC,X
	STA TXTPTR
	LDA 272+ADDPRC+ADDPRC,X
	STA TXTPTR+1
NEWSGO	JMP NEWSTT
;
LOOPDN	TXA             ;CY=1
	ADC #16+ADDPRC+ADDPRC
	TAX
	TXS             ;POP FOR-ENTRY OFF STACK
	JSR CHRGOT
	CMP #',
	BNE NEWSGO
	JSR CHRGET
	JSR GETFOR
	JMP FRMNUM
.PAG
RESTOR	BEQ RESTO1      ;NO ARGUMENT..SET POINTER TO START OF TEXT
   JSR GETPIN  ;GET LINE #
   STY LINNUM  ;STORE < OF ARG
   STA LINNUM+1 ;STORE > OF ARG
   JSR MAPTXT
   JSR FNDLIN  ;POINT TO LINK OF ARG. LINE #
   BCC RESERR ;LINE NOT FOUND
   LDA LOWTR ;FNDLIN'S RESULT
   SBC #1
   STA DATPTR
   LDA LOWTR+1
   SBC #0
   STA DATPTR+1
   RTS
RESTO1	SEC
	LDA TXTTAB
	SBC #1
	STA DATPTR
	LDA TXTTAB+1
	SBC #0
	STA DATPTR+1
RUNM10	RTS
RESERR	JMP USERR       ;UNDEF'D STATEMENT
;
;   PROCESS STOP VERB
STOP	BCS STPZ2
END	CLC
STPZ2	BNE CONTX
	BEQ STOPD       ;ALWAYS
;
;   HERE IF STOP KEY DEPRESSED WHILE RUNNING
;        ENTER: CY=0   =>  NO BREAK MESSAGE DESIRED
STOPC	PHP             ;ENTERED FROM LIST OR NEWSTT
 LDY TRAPNO+1    ;TEST IF ERROR TRAPPING ON
 INY
 BEQ SA          ;BRANCH IF NOT
UNSTOP
 JSR KSTOP       ;DON'T GO ON TILL STOP KEY NO LONGER DEPRESSED
 BEQ UNSTOP
 LDX #$1C        ;OTHERWISE LOAD 'BREAK' ERROR NUMBER
 JMP ERROR       ;AND ERROR ROUTINE WILL GOTO ERROR TRAPPING
SA	PLP
  PHA
	PHA             ;....PUSH DUMMY RETURN TO BE DISCARDED
STOPD	PHP             ; SAVE CY FLAG
	JSR TSTDIR      ;IN DIRECT MODE?
	BEQ NSXX4       ;YES...CAN'T CONTINUE
	LDA TXTPTR
	LDY TXTPTR+1
	STA OLDTXT
	STY OLDTXT+1
	LDA CURLIN
	LDY CURLIN+1
	STA OLDLIN
	STY OLDLIN+1
NSXX4	PLP             ;RESTORE CY FLAG
	PLA             ;POP OFF RETURN TO NEWSTT FROM XEQCM3
	PLA
ENDCON
	BCC NSXX6       ;IF NO BREAK MESSAGE
	LDX #BRKTXT
	JSR MSG         ;OUTPUT MESSAGE
	JMP ERRFIN
;
NSXX6	JMP READY       ;OUTPUT READY MESSAGE
;
CONT	BNE CONTX       ;MAKE SURE THERE IS A TERMINATOR
	LDY OLDTXT+1
	BNE CONTZ3      ;IF THERE IS CODE TO CONTINUE
	LDA OLDTXT
	BNE CONTZ4
	LDX #ERRCN
	JMP ERROR
CONTZ3	LDA OLDTXT
CONTZ4	STA TXTPTR
	STY TXTPTR+1
	LDA OLDLIN
	LDY OLDLIN+1
	STA CURLIN
	STY CURLIN+1
CONTX	RTS
.SKI 4
;   PROCESS RUN VERB
;
RUN	JSR RUNMOD      ;SET RUN MODE
	JSR CHRGOT      ;IS THERE A LINE # ?
	BNE RUN2        ;YES...
	JMP RUNC        ;NO...RUN FROM TXTTAB AND CLEAR STACK
RUN2	JSR CLEARC      ;RUN FROM LINE #...ONLY CLEAR STACK
	BEQ RUNC2       ;COMMON ROUTINE FOR GOTO AND GOSUB ... ALWAYS GO
;INITIALIZE RUN MODE
;CAN BE STARTED BY RUN,GOTO, OR GOSUB
;
RUNMOD	JSR TSTDIR
	BNE RUNM10      ;ALREADY RUNNING
	LDA #$FE        ;CURLIN>64999 AND <> $FF00
;                     NEITHER VALID LINE OR DIRECT MODE
	STA CURLIN+1
	LDA #0
	JMP SETMSG      ;NO LOADING MESSAGES, ETC. DURING RUN
.SKI 4
;   PROCESS GOSUB VERB
;   ON ENTRY HAS THE FOLLOWING FORMAT
;   1. THE GOSUTK ONE BYTE
;   2. THE LINE # OF THE GOSUB STATEMENT - TWO BYTES
;      (ASSUMES BANK# OF TXTPTR WILL STAY UNCHANGED)
;   3. A -> INTO THE TEXT OF THE GOSUB   - TWO BYTES
;   TOTAL OF 5 BYTES
;
GOSUB	LDA #3
	JSR GETSTK      ;MAKE SURE THERE IS ROOM
	LDA TXTPTR+1
	PHA
	LDA TXTPTR
	PHA             ;PUSH TEXT PTR ONTO STK
	LDA CURLIN+1
	PHA
	LDA CURLIN
	PHA             ;PUSH CURRENT LINE #
	LDA #TKGOSU
	PHA             ;PUSH ON A GOSUB TOKEN
RUNC2	JSR CHRGOT      ;GET CHR AND SET CODES FOR LINGET
	JSR GOTO
	JMP NEWSTT
.SKI 4
IF	JSR FRMEVL
	BIT VALTYP
	BPL IF50
	JSR FREFAC      ;IF STRING EXPR
IF50	JSR CHRGOT
	CMP #TKGOTO
	BEQ OKGOTO
	LDA #TKTHEN
	JSR SYNCHR
OKGOTO	LDA FACEXP
	BNE DOCOND
LKELSE	JSR DATA        ;SKIP TO NEXT ":" OR END-OF-LINE
	LDY #0
	LDA (TXTPTR)Y
	BEQ REM         ;EOL, NO ELSE-CLAUSE
	JSR CHRGET      ;IS STMT AN "ELSE" ?
	CMP #TKELSE
	BNE LKELSE      ;NO, KEEP LOOKING...
	JSR CHRGET      ;SKIP OVER TKELSE
DOCOND	JSR CHRGOT
	BCC GOTO
	JMP XEQCM3
.SKI 3
REM	JSR REMN        ;SCAN TO END OF LINE
	BEQ ADDON       ;ALWAYS
.SKI 4
GO	JSR CHRGOT
	LDA #TKTO
	JSR SYNCHR
;
;   PROCESS GOTO VERB
GOTO
	JSR LINGET
GOTO0	;ALWAYS GOTO0=GOTO+3
	JSR REMN
GOTO1	SEC
	LDA CURLIN
	SBC LINNUM
	LDA CURLIN+1
	SBC LINNUM+1
	BCS LUK4IT
	TYA
	SEC
	ADC TXTPTR
	LDX TXTPTR+1
	BCC LUKALL
	INX
	BCS LUKALL
LUK4IT	LDA TXTTAB
	LDX TXTTAB+1
LUKALL	JSR FNDLNC
	BCC USERR
	LDA LOWTR
	SBC #1
	STA TXTPTR
	LDA LOWTR+1
	SBC #0
	STA TXTPTR+1
	JMP    RUNMOD          ;PUT INTO RUN MODE
.SKIP
;   PROCESS RETURN VERB
RETURN	BNE ADDRTS
	LDA #MXBANK     ;IMPROBABLE BANK#
	STA FORPNT+2
	LDA #$FF        ;IMPROBABLE OFFSET(HI)
	STA FORPNT+1
	JSR FNDFOR
	TXS
	CMP #TKGOSU
	BEQ RETU1
	LDX #ERRRG
	.BYT $2C        ;EAT THE NEXT TWO BYTES
USERR	LDX #ERRUS
	JMP ERROR
;
RETU1	PLA
	PLA
	STA CURLIN
	PLA
	STA CURLIN+1
	PLA
	STA TXTPTR
	PLA
	STA TXTPTR+1
DATA	JSR DATAN
ADDON	TYA
	CLC
	ADC TXTPTR
	STA TXTPTR
	BCC ADDRTS
	INC TXTPTR+1
ADDRTS	RTS
;
DATAN	LDX #':
	.BYT $2C        ;EAT THE NEXT TWO BYTES
REMN	LDX #0
REMN1	STX CHARAC
	LDY #0
	STY ENDCHR
EXCHQT	LDA ENDCHR
	LDX CHARAC
	STA CHARAC
	STX ENDCHR
REMER	LDA TXTPTR+2
	STA I6509
	LDA (TXTPTR)Y
	BEQ REMTXT
	CMP ENDCHR
	BEQ REMTXT
	INY
	CMP #'"
	BNE REMER
	BEQ EXCHQT      ;ALWAYS
REMTXT	JMP MAPTXT
.SKI 4
TRAP	JSR ERRDIR      ;NO DIRECT MODE ALLOWED
  JSR CHRGOT ;LOOK FOR ARGUMENT
  BEQ TRAP1 ;NULL MEANS NO ARG.
  JSR GETPIN ;GET WHAT SHOULD BE A LINE NUMBER
  STY TRAPNO ;LO BYTE OF ARGUMENT
	.BYT $2C        ;EAT 2
TRAP1	LDA #$FF        ;FLAG NO TRAP
  STA TRAPNO+1
  RTS
.SKI 4
ONGOTO	JSR GETBYT
	PHA
	CMP #TKGOSU
	BEQ ONGLOP
	CMP #TKGOTO
	BEQ ONGLOP      ;IF GOTO
SNERR3	JMP SNERR
;
ONGLOP	DEC FACLO
	BNE ONGLP1
	PLA
	JMP XEQCM2
;
ONGLP1	JSR CHRGET
	JSR LINGET
	CMP #',
	BEQ ONGLOP
	PLA
ONGRTS	RTS
;
LINGET	LDX #0
	STX LINNUM
	STX LINNUM+1
MORLIN	BCS ONGRTS
	SBC #$2F
	STA CHARAC
	LDA LINNUM+1
	STA INDEX
	CMP #25
	BCS SNERR3
	LDA LINNUM
	ASL A
	ROL INDEX
	ASL A
	ROL INDEX
	ADC LINNUM
	STA LINNUM
	LDA INDEX
	ADC LINNUM+1
	STA LINNUM+1
	ASL LINNUM
	ROL LINNUM+1
	LDA LINNUM
	ADC CHARAC
	STA LINNUM
	BCC NXTLGC
	INC LINNUM+1
NXTLGC	JSR CHRGET
	JMP MORLIN
;
RESSNR	BNE SNERR3
;
LET	JSR SAV73
	LDA #TKEQUL
	JSR SYNCHR
	LDA INTFLG
	PHA
	LDA VALTYP
	PHA
	JSR FRMEVL
	PLA
	ROL A
	JSR CHKVAL
	BNE COPSTR
	PLA
QINTGR	BPL COPFLT
	JSR ROUND
	JSR AYINT
	LDA FORPNT+2
	STA I6509
	LDY #0
	LDA FACMO
	STA (FORPNT)Y
	INY
	LDA FACLO
	STA (FORPNT)Y
	JMP MAPTXT
;
COPFLT	JMP MOVVF
;
COPSTR	PLA
	JMP INPCOM
;
RESUME	JSR ERRDIR      ;NO DIRECT MODE
  LDX ERRLIN+1 ;IS THERE AN ERROR TO RESUME FRON?
  INX
  BEQ RESCNT ;CAN'T RESUME!
  JSR CHRGOT ;LOOK FOR ARGUMENTS
  BEQ RESSWP ;NO ARG'S...RESTART ERR'D LINE
  BCC RESNUM ;NUMERIC ARGUMENT
  CMP #TKNEXT ;ONLY OTHER CHOICE IS 'NEXT'
GOOOS
  BNE RESSNR ;IF NOT, SYNTAX ERROR
;
  JSR RESSWP ;RESUME EXECUTION WITH NEXT STM'T
  JSR MAPTXT
  LDY #0
  LDA (TXTPTR)Y
  BNE RESUM2  ;MUST BE A ':'
  INY ;MUST BE A NULL,GET NEXT LINE
  JSR SAV42
  JSR ADDON
RESUM2	JSR CHRGET      ;SKIP OVER THIS CHARACTER, INTO BODY OF STATEMENT
  JMP DATA ;ADVANCE UNTIL NULL OR ':', THEN RTS
;
RESNUM	JSR GETPIN      ;GET ADDRESS
  STA LINNUM+1
  JSR RESEND
  JSR MAPTXT
  JMP LUK4IT
;
RESSWP	LDX #1
RESUM0	LDA ERRLIN,X
  STA CURLIN,X
  LDA ERRTXT,X
  STA TXTPTR,X
  DEX
  BPL RESUM0
RESEND	LDX #$FF
  STX XCNT
  STX ERRLIN
  STX ERRLIN+1 ;FLAG 'NO FURTHER RESUMES UNTIL NEXT ERROR'
  LDX TMPTRP ;RESTORE TRAP LINE TO ALLOW TRAPS AGAIN
  STX TRAPNO+1
  RTS
;
RESCNT	LDX #ERRCR
  JMP ERROR
.PAG 'DISPOSE'
DISPOS	CMP #TKFOR
  BEQ DISPO0
  CMP #TKGOSU
  BNE GOOOS  ;NOT NEXT OR GOSUB IS SYNTAX ERROR
DISPO0	STA OLDTOK
  JSR ERRDIR
  TSX
  INX
  INX   ;LOOK PAST RETURN TO NEWSTT
  TXA
  TAY
DISPO1	TYA             ;Y==>X
  TAX
  CPY #$FF ;STACK EMPTY?
  BEQ DISERR ;YES...
  LDA 257,X
  CMP #TKFOR
  BNE DISPO2
  TXA  ;STACK ENTRY IS A FOR LOOP, 19 BYTES.
  ADC #18 ;+ 1 IN CARRY
  JMP DISPO3
DISPO2
  TXA ;STACK ENTRY IS GOSUB, 5 BYTES.
  CLC
  ADC #7
DISPO3
  BCS DISERR ;STACK UNDERFLOW...
  TAY
  LDA 257,X
  CMP OLDTOK
  BNE DISPO1 ;KEEP LOOKING
  BEQ DISPO5
DISPO4	LDX DSPTMP
DISPO5	LDA 256,X       ;SHIFT STACK DOWN
  STA 256,Y
  DEY
  DEX
  STX DSPTMP ;DONE WHEN X=S
  TSX
  CPX DSPTMP
  BNE DISPO4
  TYA ;S <== Y
  TAX
  TXS
  JMP CHRGET ;ADVANCE PAST MODIFIER, DO RTS
DISERR	LDX #ERRDI
  JMP ERROR
.END
