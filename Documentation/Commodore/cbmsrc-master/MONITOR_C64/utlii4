	.PAG 'UTLII4 04/30/82'
;WRITE ADR FROM TMP0 STORES
WROA
	LDA TMP0+1
	JSR WROB
	LDA TMP0
	.SKIP 3
;WRITE BYTE --- A = BYTE
;UNPACK BYTE DATA INTO TWO ASCII
;CHARACTERS. A=BYTE; X,A=CHARS
WROB	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR ASCII ;CONVERT TO ASCII
	TAX
	PLA
	AND #$0F
	JSR ASCII
	.SKIP 3
;WRITE 2 CHARS--X,A=CHARS
WRTWO	PHA
	TXA
	JSR WRT
	PLA
	JMP WRT
	.SKIP 3
; BINARY TO ASCII
;
ASCII	CLC
	ADC #$F6
	BCC ASC1
	ADC #$06
ASC1	ADC #$3A
	RTS
	.SKIP 3
T2T2	LDX #2
T2T21	LDA TMP0-1,X
	PHA
	LDA TMP2-1,X
	STA TMP0-1,X
	PLA
	STA TMP2-1,X
	DEX
	BNE T2T21
	RTS
	.SKIP 3
; SKIP SPACES READ ADR
; A=LO,X=HI
;
SKADR	LDA #0
	STA BAD
SKA10	JSR RDOC
	CMP #$20
	BEQ SKA10
	JSR RDOB2
	BCS RDOA3 ;ALWAYS
	.SKIP 3
; SKIP 1 CHAR READ ADR
; A=LO,X=HI
;
SRDAE	JSR RDOC ;SKIP THE CHAR
	.SKIP 3
;READ HEX ADR,RETURN HI IN TMP0,
;LO IN TMP0+1,AND CY=1
;IF SP CY=0
RDOA	JSR RDOB ;READ 2-CHAR BYTE
	BCC RDERR ;IF SPACE ERROR
RDOA3	TAX ;SAVE HI IN X
	JSR RDOB
	BCC RDERR ;IF SPACE ERROR
	RTS
RDERR	JMP ERROPR
	.SKIP 3
;READ HEX BYTE AND RETURN IN A
;AND CY=1 IF SP CY=0
RDOB	LDA #0 ;SPACE
	STA BAD ;READ NEXT CHAR
	JSR RDOC
RDOB1	CMP #$20
	BNE RDOB2
	JSR RDOC ;READ NEXT CHAR
	CMP #$20
	BNE RDOB3
	CLC ;CY=0
	RTS
RDOB2	JSR HEXIT ;TO HEX
	ASL A
	ASL A
	ASL A
	ASL A
	STA BAD
	JSR RDOC ;2ND CHAR ASSUMED HEX
RDOB3	JSR HEXIT
	ORA BAD
	SEC ;CY=1
	RTS
	.SKIP 3
HEXIT	CMP #$3A
	PHP ;SAVE FLAGS
	AND #$0F
	PLP
	BCC HEX09 ;0-9
	ADC #8 ;ALPHA ADD 8+CY=9
HEX09	RTS
	.SKIP 3
RDOC	JSR RDT ;READ CHAR
	CMP #$0D ;IS IT A CR
	BNE HEX09 ;NO,RTS
	JMP STRT
	.SKIP 3
STOP1	LDA STKEY
	CMP #$FE
	BNE STOP2
	PHP
	JSR CLRCH
	STA NDX
	PLP
STOP2	RTS
	.SKIP 3
; TWAIT WAIT FOR KEYBOARD IRQ
;
TWAIT
.IFE WALKON <
	LDX #$FF
	LDY #$80
TWAIT5	DEX ;KILL TIME
	BNE TWAIT5
	DEY
	BNE TWAIT5
	RTS
>
.IFN WALKON <
	JSR TSTOP ;CHECK STOP KEY
	BIT D1IFR ;GET INTERUPT BIT
	BMI TWAIT ;BRANCH IF 60 HZ IRQ ON ?
	RTS
	.SKIP 3
; TEST FOR STOP KEY
;
TSTOP
	JSR STOP1
	BNE STOP3
	JSR TNIF ;RESET I/O
	LDA #3
	STA DFLTO ;RESET DEFAULT OUTPUT
	LDA #0
	STA DFLTN ;RESET DEFAULT INPUT
STOP3	RTS
	.SKIP 3
; RESET I/O RESTORE 60 HZ IRQ
;
TNIF
	PHP
	SEI
	LDA D2PCR ;TURN OFF CASS #2
	ORA #$02
	STA D2PCR
	LDA WINTR
	STA CINV ;RE-ENABLE REPEAT KEYS
	LDA WINTR+1
	STA CINV+1
	PLP
	RTS
>
	.SKIP 3
; PUT A INTO PCH AND X INTO PCL
;
PUTP
	STA PCL
	STX PCH
	RTS
	.SKIP 3
;
;DISPLAY MEM SUBR. SET AR=NUMBER
;OF MEMORY BYTES DISPLAYED.
;TMP0=ADR OF MEM DISPLAYED
;
DM	STA TMPC2
	LDY #0
DM1	JSR SPACE ;WR N BYTES
	JSR R0BYY ;(TMP0)=ADR
	JSR WROB
	JSR INCTMP
	DEC TMPC2
	BNE DM1
	RTS
	.SKIP 3
;READ AND STORE BYTE.
;NO STORE IF SPACE OR TMPC = 0.
BYTE	JSR RDOB ;CHAR IN A, CY=0 IF SP
	BCC BY3 ;SPACE
	LDX #0 ;STORE BYTE
	JSR TOR0 ;DO THE STORE
	CMP (R0,X) ;TEST FOR VALID WRITE (RAM)
	BEQ BY3
	JMP ERROPR
BY3	JSR INCTMP ;GO INC TMP0 ADR
	DEC TMPC
	RTS
	.SKIP 3
SETR	LDA #<FLGS ;SET TO ACCESS REGS
	STA TMP0
	LDA #>FLGS
	STA TMP0+1
	LDA #5
	INC NORELO ;TURN OFF RELOCATION
	RTS
	.SKIP 3
;INCREMENT (TMP0,TMP0+1) BY 1
INCTMP	INC TMP0 ;LOW BYTE
	BNE SETWR
	INC TMP0+1 ;HIGH BYTE
	BNE SETWR
	INC WRAP
SETWR	RTS
	.SKIP 3
ALTRIT	TYA
	PHA
	JSR CRLF
	PLA
ALTR2	LDX #'.
	JSR WRTWO
	.SKIP 3
SPACE	LDA #$20
	.BYT $2C
CRLF	LDA #$D
	JMP WRT
	.SKIP 3
;
DSPLYR
	LDA INDX ;IS THIS A 2 CHARACTER COMMAND?
	CMP #2
	BCC D1X ;IF NOT THEN JUST DISPLAY REGISTERS
	JSR RDT ;CHECK FOR REMOVE BREAK POINT COMMAND
	CMP #'B
	BNE D1X ;IF NOT A REMOVE BREAK THEN DISPLAY REGISTERS
	LDA OPCODE
	CMP #$FF
	BEQ D1X ;IF NO BREAK POINT THEN DISPLAY REGISTERS
;
	LDX BRKADR ;PUT INSTRUCTION BACK
	LDY BRKADR+1
	STX TMP0
	STY TMP0+1
	LDY #0
	JSR PUTBYY ;PUT OPCODE BACK WHERE IT BELONGS
	LDA #$FF
	STA OPCODE
	JMP STRT ;GO BACK AND LOOK FOR MORE COMMANDS
;
D1X	LDX #0
D2	LDA REGK,X
	JSR WRT
	INX
	CPX #22
	BNE D2
	JSR CRLF ;START ON NEXT LINE
	LDX #'.
	LDA #';
	JSR WRTWO
	LDA PCH
	JSR WROB
	LDA PCL
	JSR WROB
	JSR SETR
	JSR DM ;USE DM SUBR.
	DEC NORELO ;TURN ON RELOCATION
BEQS1	JMP STRT
ERRS1	JMP ERROPR
	.SKIP 3
;ALTER REGISTERS
;
ALTR	JSR SKADR ;SKIP SPACES READ ADR
	JSR PUTP ;ALTER PC
	JSR SETR ;SET TO ALTER R'S - TURN OFF RELOCATION
	STA TMPC
A5	JSR RDOC
	JSR BYTE
	BNE A5
	DEC NORELO ;TURN RELOCATION BACK ON
	BEQ BEQS1
	.SKIP 3
EXIT
	SEI ;DON'T ALLOW INTERUPTS WHILE I ...
	JSR RESIRQ ;RESTORE HIS IRQ VECTOR
	LDX SP
	TXS
	JSR SWAP
	JMP ($A002) ;WARM START BASIC
	.SKIP 3
ERRL	JMP ERROPR
	.SKIP 3
; LOAD/SAVE
;
LD
	LDY #1
	STY FA ;DEFAULT DEVICE #1
	STY SA ;DEFAULT SA IS 1 FOR LOAD ONLY
	DEY
	STY FNLEN
	STY SATUS ;CLEAR STATUS ON LOAD
	STY VERCK
	LDA #>MTCH ;PLACE TO STORE NAME
	STA FNADR+1
	LDA #<MTCH
	STA FNADR
L1	JSR RDT
	CMP #$20
	BEQ L1 ;SPAN BLANKS
	CMP #CR
	BEQ L5 ;DEFAULT TO LOAD
	CMP #'"
L2	BNE ERRL ;FILE NAME MUST BE NEXT
L3	JSR RDT
	CMP #'"
	BEQ L8 ;END OF NAME
	CMP #CR ;DEFAULT A LOAD
	BEQ L5
	STA (FNADR)Y
	INC FNLEN
	INY
	CPY #16
L4	BEQ ERRL ;FILE NAME TOO LONG
	BNE L3
L5	LDA SAVCMD
	CMP #'L ;REALLY A LOAD CMD ?
L6	BNE L2 ;NOT A LOAD
	LDA #0 ;NO VERIFY FLAG
	JSR LD15B2 ;YES
;
LL77	JSR TWAIT
	LDA SATUS
	AND #SPERR
L7	BNE L6 ;LOAD ERROR
	JMP STRT
L8	JSR RDT
	CMP #CR
	BEQ L5 ;DEFUALT LOAD
	CMP #',
L9	BNE L7 ;BAD SYNTAX
	JSR RDOB
	AND #$F
L10	BEQ L4 ;DEVICE 0
	CMP #3
L11	BEQ L10 ;DEVICE 3
	STA FA
	JSR RDT
	CMP #CR
	BEQ L5 ;DEFAULT LOAD
	CMP #',
L12	BNE L9 ;BAD SYNTAX
	JSR RDTMP0 ;READ ADR INTO TMP0
	JSR RDT
	CMP #',
L13	BNE L12 ;MISSING END ADDR
	JSR RDOA
	STA EAL
	STX EAL+1
L20	JSR RDT
	CMP #$20
	BEQ L20
	CMP #CR
L14	BNE L13 ;MISSING CR AT END
	LDA SAVCMD
	CMP #'S ;REALLY A SAVE CMD ?
	BNE L14
	JSR CRLF ;START 'SAVING...' MSG ON NEXT LINE
	LDA #0
	STA SA
	LDX EAL
	LDY EAL+1
	LDA #<TMP0
	JSR SV5B2 ;YES
	JMP STRT
;
	.SKIP 5
	.END
