	.PAGE 'TRNII4 10/23/80'
; COMPARE MEMORY
; SYNTAX C 0000 1111 2222
;
COMPAR	LDA #0 ;SET FLAG FOR COMPARE
	BEQ TR10 ;ALWAYS
	.SKIP 2
; TRANSFER MEMORY
; SYNTAX T 0000 1111 2222
;
TRANS	LDA #1 ;SET FLAG FOR TRANSFER
TR10	STA TMPC4
	JSR PARM3 ;GET TMP0=NA,TMP2=SA,TMP10=EA
	JSR CRLF ;START ON NEW LINE
	JSR DCMP ;C=0 FOR TRANSFER UP
	JSR T2T2 ;TMP0=SA,TMP2=NA,TMP10=EA
	BCC TRUP ;TRANSFER UP
TRDWN	JSR DCT10 ;SUB SA FROM EA
	BCS TTTDDD
	JMP FSTR ;STOP IF EA<SA
;
TTTDDD	JSR TRNCMP ;DO TRANSFER OR COMPAIR
	INC TMP2 ;INC TMP2
	BNE TTT10 ;NO CARRY
	INC TMP2+1
TTT10	JSR INCTMP ;INC TMP0
	LDY WRAP ;OVERFLOW $FFFF ?
	BNE FIXSTK ;YES THEN DONE
	BEQ TRDWN ;BRANCH ALWAYS
	.SKIP 2
TRUP	JSR DCT10 ;EA-SA
	CLC ;CALC NEW END ADR
	LDA DIFF ;LO DIFF
	ADC TMP2 ;ADD LO NEW ADR
	STA TMP2
	TYA ;GET HI DIFF
	ADC TMP2+1 ;ADD HI NEW ADR
	STA TMP2+1
	JSR T0T10 ;TMP0=EA,TMP2=NEW EA
; TMP10=SA
TR40	JSR TRNCMP ;DO TRANSFER OR COMPARE
	JSR DCT10 ;IS EA=SA
	BCS FSTR ;YES-DONE
	JSR DECT2 ;DEC TMP2
	JSR DECT0 ;DEC TMP0
	LDY WRAP ;OVER $FFFF ?
	BNE FIXSTK ;YES - END
	BEQ TR40
	.SKIP 3
TRNCMP	LDX #0
	JSR FROMR0 ;GET BYTE
	PHA ;SAVE IT TO SETUP OTHER ADDRESS
	JSR FROMR2 ;INCASE WE DO A COMPARE
	PLA ;RESTORE SOURCE BYTE
	LDY TMPC4 ;A TRANSFER ?
	BEQ TRC10 ;NO
	JSR TOR2  ;YES - TRANSFER IT
TRC10	CMP (R0,X) ;DID IT STICK ?
	BEQ TRTS ;YES
PRTADR	JSR WROA ;NO - PRINT BAD ADDRESS
	JSR SPACE
	JSR STOP1 ;STOP KEY ?
	BEQ FIXSTK ;YES
TRTS	RTS ;NO - RETURN
FIXSTK
	JMP STRT
	.SKIP 3
; FILL MEMORY
; SYNTAX F 0000 1111 22
;
FILL	JSR SKTMP0 ;SKIP SP'S READ SA TO TMP2
	JSR SKTMP2 ;SKIP 1 READ EA
	JSR RDOC ;SKIP 1 ,CHECK FOR ERROR
	JSR RDOB ;READ FILL BYTE
	BCC ERRF2
	STA TMPC ;SAVE IT
FL10	LDX WRAP ;STOP IF WRAP
	BNE FSTR
	JSR DCMP ;STOP IF EA<SA
	BCC FSTR
	LDA TMPC ;GET FILL BYTE
	JSR TOR0 ;PUT IN MEMORY
	JSR INCTMP ;INC TMP0
	BNE FL10 ;BRANCH ALWAYS
ERRF2	JMP ERROPR
FSTR	JMP STRT
	.SKIP 3
; HUNT FOR BYTES OR STRING
; SYNTAX H 0000 1111 'AF...
; OR H 0000 1111 22 33 44 ...
;
HUNT	JSR SKTMP0 ;SKIP SP'S READ SA TO TMP2
	JSR SKTMP2 ;SKIP 1 READ A
	JSR RDOC ;SKIP 1 DELIMITER
	LDX #0
	JSR RDOC ;GET FIRST CHAR
	CMP #$27 ;IS IT A '
	BNE HT50 ;NO-MUST BE HEX
	JSR RDOC ;YES-GET FIRST STRING CHR
HT30	STA MTCH,X ;SAVE IN BUF
	INX
	JSR RDT ;GET NEXT
	CMP #$0D ;A CR?
	BEQ HT80 ;YES-END OF STRING
	CPX #$20 ;NO-32 CHAR YET?
	BNE HT30 ;NO-GET MORE
	BEQ HT80 ;YES-GO LOOK FOR IT
HT50	STX BAD ;ZERO FOR RDOB
	JSR RDOB1 ;FINISH HEX READ
	BCC ERRF2
HT60	STA MTCH,X ;SAVE IN BUF
	INX
	JSR RDT ;GET DELIMITER
	CMP #$0D ;IS IT A CR?
	BEQ HT80 ;YES-GO LOOK FOR BYTES
	JSR RDOB ;NO-GET THE BYTE
	BCC ERRF2
	CPX #$20 ;32 BYTES YET?
	BNE HT60 ;NO-GET MORE
HT80	STX SAVX ;YES-START SEARCH
	JSR CRLF ;NEXT LINE
HT85	LDX #0
	LDY #0
	LDA TMP0 ;SAVE START ADDRESS ON STACK
	PHA
	LDA TMP0+1
	PHA
HT90	JSR R0BYY  ;GET BYTE
	CMP MTCH,X ;SAME?
	BNE HT100 ;NO-MOVE ON
	JSR INCTMP ;YES-TRY NEXT IN BUF - BUMP TMP0
	INX
	CPX SAVX ;CHECKED FULL STRING?
	BNE HT90 ;NO-CHECK ON
;
	PLA
	STA TMP0+1
	PLA
	STA TMP0
	JSR PRTADR ;YES - PRINT ADDRESS FOUND
	BNE NXT1
HT100
	PLA
	STA TMP0+1
	PLA
	STA TMP0
NXT1	JSR INCTMP ;TRY NEXT ADR
	LDY WRAP ;OVER $FFFF ?
	BNE SSTR ;YES
	JSR DCMP ;IS EA<SA ?
	BCS HT85 ;NO-LOOP
SSTR	JMP STRT ;YES - STOP
	.SKIP 5
	.END
