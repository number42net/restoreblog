.PAGE 'UTLODR'
;********************************
;*UTLODR-UTILITY LOADER USED TO
; LOAD USER PROGRAMS OR SYSTEM
; UTILITIES FROM DISK AND
; EXECUTE THEM.
;
; THIS LOADER IS DESIGNED TO BE
; INCORPORATED INTO THE 1540 DOS
; SYSTEM (SERIAL BUS INTERFACE).
;
; HARDWARE REQIRED :
;  CONNECT DATA AND CLOCK LINE TO
;  GROUND. (2-4-5 ON CONNECTOR)
;
;********************************
;*ON ENTRY-
; ONLY REQUIREMENT IS THAT THE
; FILENAME OF THE FILE TO BE
; LOADED BE THE FIRST SPECIFIED
; NAME IN CMDBUF (THE COMMAND
; BUFFER).
;
; REGISTERS: IGNORED
;
;*ON EXIT-
; IF THE FILE EXISTED ON DISK AND
; COULD BE FOUND, AND NO CHECKSUM
; ERRORS WERE ENCOUNTERED WHILE
; LOADING IT, IT IS NOW LOADED
; INTO MEMORY, READY TO EXECUTE.
;
; REGISTERS: ALL DESTROYED
;
; EXECUTION OF THE LOADED PROGRAM
; IS STARTED AT THE FIRST BYTE
; LOADED.
;
; CMDBUF CONTAINS THE PARAMETER
; STRING FOR THE FRESHLY LOADED
; UTILITY OR USER PROGRAM.
;
;********************************
.PAG
;********************************
;
;*FIRST WRITING-
; 25-JAN-80
; BY RON STEPHENS
;
;--------------------------------
;
;*REVISION LIST-
; 28-FEB-80  S. PATTERSON - ADD PARSER INTERFACE
; 09-APR-81 RSR - CHANGE FOR SERIAL BUS
;
;********************************
.PAG
;********************************
;
;*ROUTINES EXTERNAL TO THIS
; MODULE THAT ARE USED:
;
; LOOKUP-
;   FUNCTION-FINDS FIRST NAME
;   SPECIFIED IN CMDBUF IN THE
;   DISK DIRECTORY ON THE SPECIFIED
;   DRIVE.
;
;   INPUTS FROM UTLODR-NONE
;   OUTPUTS TO UTLODR-NONE
;
; CHKIN-
;   FUNCTION-CHECKS IF NAME WAS
;   FOUND BY LOOKUP. ERROR IF NOT
;   FOUND. EXITS TO 8050 ERROR
;   ROUTINE.
;
;   INPUTS FROM UTLODR-NONE
;   OUTPUTS TO UTLODR-NONE
;
; GIBYTE-
;   FUNCTION-FETCHES NEXT BYTE
;   FROM OPEN FILE. ALSO SETS
;   EOIFLG ZERO IF END OF FILE
;   CONDITION DETECTED.
;
;   INPUTS FROM UTLODR-NONE
;   OUTPUTS TO UTLODR-VARIABLE 'DATA' CONTAINS
;   THE DATA BYTE.
;
; OPNTYP-
;   FUNCTION-OPENS FILE PREVIOUSLY
;   "LOOKED UP" BY LOOKUP ABOVE.
;   CALLS ERROR ROUTINE IF
;   TYPE DOESN'T MATCH THAT SPECIFIED
;
;   INPUTS FROM UTLODR-.A=FILE TYPE
;   (5 IN OUR CASE)
;   OUTPUTS TO UTLODR-NONE
;
; CMDER2-
;   FUNCTION-PLACES ERROR MESSAGE
;   SPECIFIED INTO ERROR BUFFER.
;
;   INPUTS FROM UTLODR-.A=ERROR NUMBER
;   OUTPUTS TO UTLODR-NONE
;
;********************************
.PAG
BOOT2
	RTS             ;EXIT
;
BOOT	;POWER-ON DIAG SENSE LOADER
	LDA PB          ;GET PORT DATA
	TAX             ;SAVE FOR LATER
	AND #CLKIN      ;CHECK FOR CLK TO GND
	BEQ BOOT2       ;NO...EXIT
	TXA
	AND #DATIN      ;CHECK FOR DATA TO GND
	BEQ BOOT2       ;NO...EXIT
	CLI             ;SO BACKGND WILL RUN!
;
;BOOT CLIP MUST BE ON
BOOT3
	LDA PB
	AND #CLKIN+DATIN
	BNE BOOT3       ;WAIT UNTILL REMOVED?
;
	INC F2CNT       ;SET # FILES
	INC CMDSIZ      ;SET # OF CHARS
	LDA #'*
	STA CMDBUF      ;SET FILENAME FOR ANY MATCH
;
	JMP BOOT4
;
;
;*ENTRY POINT
;
UTLODR
	LDA #$8D
	JSR PARSE
BOOT4
	JSR KILLP       ;KILL PROTECT
	LDA F2CNT
	PHA             ;SAVE FILE COUNT FOR UTILITY
	LDA #1
	STA F2CNT
	LDA #$FF        ;INIT FIRSTBYTE FLAG
	STA R0          ;R0 IS FLAG
;
	JSR LOOKUP      ;LOCATE FILENAME ON DISK
;
	LDA FILTRK      ;CHECK IF FOUND. ERR IF NOT
	BNE UTLD00
	LDA #NOCFIL
	JSR CMDERR
UTLD00
	PLA
	STA F2CNT       ;RESTORE FILE COUNT
;
	LDA FILTRK      ;INIT TRK, SCTR FOR OPEN
	STA TRACK
	LDA FILSEC
	STA SECTOR
;
	LDA #USRTYP     ;OPEN SYSTEM TYPE FILE( 5 )
	JSR OPNTYP      ;OPEN
;
;********************************
;
;*FILE RECORD FETCH LOOP
UTLD10	LDA #$00        ;INIT CHECKSUM
	STA R1          ;CALC. CHKSUM RESIDES IN R1
;
	JSR GTABYT      ;FETCH LOAD ADDRESS LO
	STA R2
	JSR ADDSUM      ;ADD INTO CHECKSUM
;
	JSR GTABYT      ;FETCH LOAD ADDRESS HI
	STA R3
	JSR ADDSUM
;
	LDA R0          ;IS THIS THE FIRSTBYTE ADDRESS?
	BEQ UTLD20      ;BR IF NOT
	LDA R2          ;SAV AWAY THIS ADDR. IN2 STACK
	PHA             ;LO FIRST
	LDA R3
	PHA             ;HI NEXT
	LDA #$00        ;CLEAR FLAG
	STA R0          ;FIRSTBYTE FLAG
;
UTLD20	JSR GTABYT      ;FETCH DATA BYTE COUNT
	STA R4          ;SAVE IN R4
	JSR ADDSUM      ;ADD INTO CHECKSUM
;
;********************************
;
;*BYTE STORE LOOP
UTLD30	JSR GTABYT      ;FETCH DATA BYT
	LDY #$00        ;INIT INDEX
	STA (R2),Y      ;STORE BYTE AT DESIRED ADDRESS
	JSR ADDSUM      ;ADD INTO CHECKSUM
;
	LDA R2          ;POINTER:=POINTER+1
	CLC
	ADC #$01
	STA R2
	BCC UTLD35
	INC R3          ;ADD IN CARRY
;
UTLD35	DEC R4          ;UPDATE BYTE COUNTER
	BNE UTLD30      ;IF NONZERO, CONTINUE
;*END OF BYTE STORE LOOP
;
;********************************
;
	JSR GIBYTE      ;GET A BYTE WITHOUT CHECK FOR EOI
	LDA DATA
	CMP R1          ;LAST BYTE FETCHED WAS CHKSUM
	BEQ UTLD50      ;IF SAME...EVERYTHING OK
	JSR GETHDR
	LDA #NOREC      ;SHOW RECORD OVERFLOW
	JSR CMDER2      ;AND LEAVE TO ERROR EXIT
;
UTLD50	LDA EOIFLG      ;CHECK FOR END OF FILE
	BNE UTLD10      ;IF NONZERO, NOT DONE
;*END OF RECORD LOAD LOOP
;
;********************************
;
	PLA             ;XFER CNTRL TO 1ST BYTE ADDR.
	STA R3
	PLA
	STA R2
	JMP (R2)
.PAG
;********************************
;
;*LOCAL ROUTINES USED BY UTLODR
;
.SKI
;********************************
;
;*GTABYT-FETCHES A BYTE FROM THE
;        FILE OPEN ON THE INTERNAL
;        CHANNEL. CHECKS IF THIS
;        WAS THE LAST BYTE IN THE
;        FILE. ERROR IF IT WAS.
;        SHOW A 'PTER' (PREMATURE
;        TERMINATION ERROR).
;
;********************************
;
;*ENTRY POINT
;
GTABYT	JSR GIBYTE      ;FETCH A BYTE TO DATA LOC
	LDA EOIFLG      ;CHECK IF EOF EXISTS
	BNE GTABYE      ;OK IF NONZERO
	JSR GETHDR
	LDA #RECOVF     ;RECORD SIZE ERROR
	JSR CMDER2      ;CALL 8050 ERROR ROUTINE
;
GTABYE	LDA DATA
	RTS
.SKI 2
;********************************
;
;*ADDSUM-ADDS UP CHECKSUM INTO
;        LOCATION R1. ALGORITHM:
;        NEWSUM:=OLDSUM+NEWBYTE+
;        CARRY
;
; INPUTS: EXPECTS NEWBYTE IN .A
; OUTPUTS: R1=NEWSUM, .A DESTROYED
;
;********************************
;
;*ENTRY POINT
;
ADDSUM	CLC
	ADC R1          ;.A=.A+R1
	ADC #$00        ;.A=.A+CARRY
	STA R1          ;SAVE NEW CHECKSUM
	RTS
;
.END
